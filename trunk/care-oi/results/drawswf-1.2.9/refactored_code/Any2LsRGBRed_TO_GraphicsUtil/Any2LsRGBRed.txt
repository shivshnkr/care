/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package org.apache.batik.ext.awt.image.rendered;


import org.apache.batik.ext.awt.image.GraphicsUtil;

import java.awt.Point;
import java.awt.Rectangle;

import java.awt.color.ColorSpace;

import java.awt.image.BandCombineOp;
import java.awt.image.BufferedImage;
import java.awt.image.ColorConvertOp;
import java.awt.image.ColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.SampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;

/**
 * This function will tranform an image from any colorspace into a
 * luminance image.  The alpha channel if any will be copied to the
 * new image.
 *
 * @author <a href="mailto:Thomas.DeWeeese@Kodak.com">Thomas DeWeese</a>
 * @version $Id: Any2LsRGBRed.java,v 1.1 2003/04/11 07:56:53 tom Exp $ */
public class Any2LsRGBRed extends AbstractRed {

    boolean srcIssRGB = false;

    /**
     * Construct a luminace image from src.
     *
     * @param src The image to convert to a luminance image
     */
    public Any2LsRGBRed(CachableRed src) {
        super(src,src.getBounds(), 
              fixColorModel(src),
              fixSampleModel(src),
              src.getTileGridXOffset(),
              src.getTileGridYOffset(),
              null);

        ColorModel srcCM = src.getColorModel();
        if (srcCM == null) return;
        ColorSpace srcCS = srcCM.getColorSpace();
        if (srcCS == ColorSpace.getInstance(ColorSpace.CS_sRGB))
            srcIssRGB = true;
    }

    /**
     * Gamma for linear to sRGB convertion
     */
    private static final double GAMMA = 2.4;
    private static final double LFACT = 1.0/12.92;


    public static final double sRGBToLsRGB(double value) {
        if(value <= 0.003928)
            return value*LFACT;
        return Math.pow((value+0.055)/1.055, GAMMA);
    }

    /**
     * Lookup tables for RGB lookups. The linearToSRGBLut is used
     * when noise values are considered to be on a linearScale. The
     * linearToLinear table is used when the values are considered to
     * be on the sRGB scale to begin with.
     */
    private static final int sRGBToLsRGBLut[] = new int[256];
    static {
        final double scale = 1.0/255;

        // System.out.print("S2L: ");
        for(int i=0; i<256; i++){
            double value = sRGBToLsRGB(i*scale);
            sRGBToLsRGBLut[i] = (int)Math.round(value*255.0);
            // System.out.print(sRGBToLsRGBLut[i] + ",");
        }
        // System.out.println("");
    }

    public WritableRaster copyData(WritableRaster wr) {
        // Get my source.
        CachableRed src   = (CachableRed)getSources().get(0);
        ColorModel  srcCM = src.getColorModel();
        SampleModel srcSM = src.getSampleModel();

        // Fast case, SRGB source, INT Pack writable raster...
        if (srcIssRGB && 
            Any2sRGBRed.is_INT_PACK_COMP(wr.getSampleModel())) {
            src.copyData(wr);
            if (srcCM.hasAlpha())
                coerceData(wr, srcCM, false);
            Any2sRGBRed.applyLut_INT(wr, sRGBToLsRGBLut);
            return wr;
        }

        if (srcCM == null) {
            // We don't really know much about this source, let's
            // guess based on the number of bands...

            float [][] matrix = null;
            switch (srcSM.getNumBands()) {
            case 1:
                matrix = new float[1][3];
                matrix[0][0] = 1; // Red
                matrix[0][1] = 1; // Grn
                matrix[0][2] = 1; // Blu
                break;
            case 2:
                matrix = new float[2][4];
                matrix[0][0] = 1; // Red
                matrix[0][1] = 1; // Grn
                matrix[0][2] = 1; // Blu
                matrix[1][3] = 1; // Alpha
                break;
            case 3:
                matrix = new float[3][3];
                matrix[0][0] = 1; // Red
                matrix[1][1] = 1; // Grn
                matrix[2][2] = 1; // Blu
                break;
            default:
                matrix = new float[srcSM.getNumBands()][4];
                matrix[0][0] = 1; // Red
                matrix[1][1] = 1; // Grn
                matrix[2][2] = 1; // Blu
                matrix[3][3] = 1; // Alpha
                break;
            }

            Raster srcRas = src.getData(wr.getBounds());
            BandCombineOp op = new BandCombineOp(matrix, null);
            op.filter(srcRas, wr);
        } else {
            ColorModel dstCM = getColorModel();
            BufferedImage dstBI;

            if (!dstCM.hasAlpha()) {
                // No alpha ao we don't have to work around the bug
                // in the color convert op.
                dstBI = new BufferedImage
                    (dstCM, wr.createWritableTranslatedChild(0,0),
                     dstCM.isAlphaPremultiplied(), null);
            } else {
                // All this nonsense is to work around the fact that
                // the Color convert op doesn't properly copy the
                // Alpha from src to dst.
                SinglePixelPackedSampleModel dstSM;
                dstSM = (SinglePixelPackedSampleModel)wr.getSampleModel();
                int [] masks = dstSM.getBitMasks();
                SampleModel dstSMNoA = new SinglePixelPackedSampleModel
                    (dstSM.getDataType(), dstSM.getWidth(), dstSM.getHeight(), 
                     dstSM.getScanlineStride(), 
                     new int[] {masks[0], masks[1], masks[2]});
                ColorModel dstCMNoA = Linear_sRGB;

                WritableRaster dstWr;
                dstWr = Raster.createWritableRaster(dstSMNoA,
                                                    wr.getDataBuffer(),
                                                    new Point(0,0));
                dstWr = dstWr.createWritableChild
                    (wr.getMinX()-wr.getSampleModelTranslateX(),
                     wr.getMinY()-wr.getSampleModelTranslateY(),
                     wr.getWidth(), wr.getHeight(),
                     0, 0, null);
                
                dstBI = new BufferedImage(dstCMNoA, dstWr, false, null);
            }

            // Divide out alpha if we have it.  We need to do this since
            // the color convert may not be a linear operation which may 
            // lead to out of range values.
            ColorModel srcBICM = srcCM;
            WritableRaster srcWr;
            if ((srcCM.hasAlpha() == true) && 
                (srcCM.isAlphaPremultiplied() != false)) {
                Rectangle wrR = wr.getBounds();
                SampleModel sm = srcCM.createCompatibleSampleModel
                    (wrR.width, wrR.height);
                
                srcWr = Raster.createWritableRaster
                    (sm, new Point(wrR.x, wrR.y));
                src.copyData(srcWr);
                srcBICM = GraphicsUtil.coerceData(srcWr, srcCM, false);
            } else {
                Raster srcRas = src.getData(wr.getBounds());
                srcWr = makeRasterWritable(srcRas);
            }

            BufferedImage srcBI;
            srcBI = new BufferedImage(srcBICM, 
                                      srcWr.createWritableTranslatedChild(0,0),
                                      false, 
                                      null);

            /*
             * System.out.println("src: " + srcBI.getWidth() + "x" + 
             *                    srcBI.getHeight());
             * System.out.println("dst: " + dstBI.getWidth() + "x" + 
             *                    dstBI.getHeight());
             */

            ColorConvertOp op = new ColorConvertOp(null);
            op.filter(srcBI, dstBI);

            if (dstCM.hasAlpha())
                copyBand(srcWr, srcSM.getNumBands()-1,
                         wr,    getSampleModel().getNumBands()-1);
        }
        return wr;
    }

        /**
         * This function 'fixes' the source's color model.  Right now
         * it just selects if it should have one or two bands based on
         * if the source had an alpha channel.
         */
    protected static ColorModel fixColorModel(CachableRed src) {
        ColorModel  cm = src.getColorModel();
        if (cm != null) {
            if (cm.hasAlpha())
                return Linear_sRGB_Unpre;

            return Linear_sRGB;
        }
        else {
            // No ColorModel so try to make some intelligent
            // decisions based just on the number of bands...
            // 1 bands -> replicated into RGB
            // 2 bands -> Band 0 replicated into RGB & Band 1 -> alpha premult
            // 3 bands -> sRGB (not-linear?)
            // 4 bands -> sRGB premult (not-linear?)
            SampleModel sm = src.getSampleModel();

            switch (sm.getNumBands()) {
            case 1:
                return Linear_sRGB;
            case 2:
                return Linear_sRGB_Unpre;
            case 3:
                return Linear_sRGB;
            }
            return Linear_sRGB_Unpre;
        }
    }

    /**
     * This function 'fixes' the source's sample model.
     * Right now it just selects if it should have 3 or 4 bands
     * based on if the source had an alpha channel.
     */
    protected static SampleModel fixSampleModel(CachableRed src) {
        SampleModel sm = src.getSampleModel();
        ColorModel  cm = src.getColorModel();

        int width  = sm.getWidth();
        int height = sm.getHeight();

        boolean alpha = false;

        if (cm != null)
            alpha = cm.hasAlpha();
        else {
            switch (sm.getNumBands()) {
            case 1: case 3:
                alpha = false;
                break;
            default:
                alpha = true;
                break;
            }
        }
        if (alpha)
            return new SinglePixelPackedSampleModel
                (DataBuffer.TYPE_INT,
                 sm.getWidth(),
                 sm.getHeight(),
                 new int [] {0xFF0000, 0xFF00, 0xFF, 0xFF000000});
        else
            return new SinglePixelPackedSampleModel
                (DataBuffer.TYPE_INT,
                 sm.getWidth(),
                 sm.getHeight(),
                 new int [] {0xFF0000, 0xFF00, 0xFF});
    }

	/**
	 * Coerces data within a bufferedImage to match newAlphaPreMult, Note that this can not change the colormodel of bi so you
	 * @param wr  The raster to change the state of.
	 * @param cm  The colormodel currently associated with data in wr.
	 * @param newAlphaPreMult  The desired state of alpha Premult for raster.
	 * @return  A new colormodel that matches newAlphaPreMult.
	 */
	public static ColorModel coerceData(WritableRaster wr, ColorModel cm,
			boolean newAlphaPreMult) {
		if (cm.hasAlpha() == false)
			return cm;
		if (cm.isAlphaPremultiplied() == newAlphaPreMult)
			return cm;
		int[] pixel = null;
		int bands = wr.getNumBands();
		float norm;
		if (newAlphaPreMult) {
			if (is_BYTE_COMP_Data(wr.getSampleModel()))
				mult_BYTE_COMP_Data(wr);
			else if (is_INT_PACK_Data(wr.getSampleModel(), true))
				mult_INT_PACK_Data(wr);
			else {
				norm = 1f / 255f;
				int x0, x1, y0, y1, a, b;
				float alpha;
				x0 = wr.getMinX();
				x1 = x0 + wr.getWidth();
				y0 = wr.getMinY();
				y1 = y0 + wr.getHeight();
				for (int y = y0; y < y1; y++)
					for (int x = x0; x < x1; x++) {
						pixel = wr.getPixel(x, y, pixel);
						a = pixel[bands - 1];
						if ((a >= 0) && (a < 255)) {
							alpha = a * norm;
							for (b = 0; b < bands - 1; b++)
								pixel[b] = (int) (pixel[b] * alpha + 0.5f);
							wr.setPixel(x, y, pixel);
						}
					}
			}
		} else {
			if (is_BYTE_COMP_Data(wr.getSampleModel()))
				divide_BYTE_COMP_Data(wr);
			else if (is_INT_PACK_Data(wr.getSampleModel(), true))
				divide_INT_PACK_Data(wr);
			else {
				int x0, x1, y0, y1, a, b;
				float ialpha;
				x0 = wr.getMinX();
				x1 = x0 + wr.getWidth();
				y0 = wr.getMinY();
				y1 = y0 + wr.getHeight();
				for (int y = y0; y < y1; y++)
					for (int x = x0; x < x1; x++) {
						pixel = wr.getPixel(x, y, pixel);
						a = pixel[bands - 1];
						if ((a > 0) && (a < 255)) {
							ialpha = 255 / (float) a;
							for (b = 0; b < bands - 1; b++)
								pixel[b] = (int) (pixel[b] * ialpha + 0.5f);
							wr.setPixel(x, y, pixel);
						}
					}
			}
		}
		return coerceColorModel(cm, newAlphaPreMult);
	}

	/**
	 * Coerces <tt>ras</tt> to be writable.  The returned Raster continues to reference the DataBuffer from ras, so modifications to the returned WritableRaster will be seen in ras.<p> This method should only be used if you need a WritableRaster due to an interface (such as to construct a BufferedImage), but have no intention of modifying the contents of the returned Raster.  If you have any doubt about other users of the data in <tt>ras</tt>, use copyRaster (above).
	 * @param ras  The raster to make writable.
	 * @return     A Writable version of ras (shares DataBuffer with <tt>ras</tt>).
	 */
	public static WritableRaster makeRasterWritable(Raster ras) {
		return makeRasterWritable(ras, ras.getMinX(), ras.getMinY());
	}

	public static boolean is_BYTE_COMP_Data(SampleModel sm) {
		if (!(sm instanceof ComponentSampleModel))
			return false;
		if (sm.getDataType() != DataBuffer.TYPE_BYTE)
			return false;
		return true;
	}

	protected static void mult_BYTE_COMP_Data(WritableRaster wr) {
		ComponentSampleModel csm;
		csm = (ComponentSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = csm.getScanlineStride();
		final int pixStride = csm.getPixelStride();
		final int[] bandOff = csm.getBandOffsets();
		DataBufferByte db = (DataBufferByte) wr.getDataBuffer();
		final int base = (db.getOffset() + csm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int a = 0;
		int aOff = bandOff[bandOff.length - 1];
		int bands = bandOff.length - 1;
		int b, i;
		final byte pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width * pixStride;
			while (sp < end) {
				a = pixels[sp + aOff] & 0xFF;
				if (a != 0xFF)
					for (b = 0; b < bands; b++) {
						i = sp + bandOff[b];
						pixels[i] = (byte) (((pixels[i] & 0xFF) * a) >> 8);
					}
				sp += pixStride;
			}
		}
	}

	public static boolean is_INT_PACK_Data(SampleModel sm, boolean requireAlpha) {
		if (!(sm instanceof SinglePixelPackedSampleModel))
			return false;
		if (sm.getDataType() != DataBuffer.TYPE_INT)
			return false;
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) sm;
		int[] masks = sppsm.getBitMasks();
		if (masks.length == 3) {
			if (requireAlpha)
				return false;
		} else if (masks.length != 4)
			return false;
		if (masks[0] != 0x00ff0000)
			return false;
		if (masks[1] != 0x0000ff00)
			return false;
		if (masks[2] != 0x000000ff)
			return false;
		if ((masks.length == 4) && (masks[3] != 0xff000000))
			return false;
		return true;
	}

	protected static void mult_INT_PACK_Data(WritableRaster wr) {
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = sppsm.getScanlineStride();
		DataBufferInt db = (DataBufferInt) wr.getDataBuffer();
		final int base = (db.getOffset() + sppsm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int n = 0;
		final int pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width;
			while (sp < end) {
				int pixel = pixels[sp];
				int a = pixel >>> 24;
				if ((a >= 0) && (a < 255)) {
					pixels[sp] = ((a << 24)
							| ((((pixel & 0xFF0000) * a) >> 8) & 0xFF0000)
							| ((((pixel & 0x00FF00) * a) >> 8) & 0x00FF00) | ((((pixel & 0x0000FF) * a) >> 8) & 0x0000FF));
				}
				sp++;
			}
		}
	}

	protected static void divide_BYTE_COMP_Data(WritableRaster wr) {
		ComponentSampleModel csm;
		csm = (ComponentSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = csm.getScanlineStride();
		final int pixStride = csm.getPixelStride();
		final int[] bandOff = csm.getBandOffsets();
		DataBufferByte db = (DataBufferByte) wr.getDataBuffer();
		final int base = (db.getOffset() + csm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int a = 0;
		int aOff = bandOff[bandOff.length - 1];
		int bands = bandOff.length - 1;
		int b, i;
		final byte pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width * pixStride;
			while (sp < end) {
				a = pixels[sp + aOff] & 0xFF;
				if (a == 0) {
					for (b = 0; b < bands; b++)
						pixels[sp + bandOff[b]] = (byte) 0xFF;
				} else if (a < 255) {
					int aFP = (0x00FF0000 / a);
					for (b = 0; b < bands; b++) {
						i = sp + bandOff[b];
						pixels[i] = (byte) (((pixels[i] & 0xFF) * aFP) >>> 16);
					}
				}
				sp += pixStride;
			}
		}
	}

	protected static void divide_INT_PACK_Data(WritableRaster wr) {
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = sppsm.getScanlineStride();
		DataBufferInt db = (DataBufferInt) wr.getDataBuffer();
		final int base = (db.getOffset() + sppsm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int pixel, a, aFP, n = 0;
		final int pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width;
			while (sp < end) {
				pixel = pixels[sp];
				a = pixel >>> 24;
				if (a <= 0) {
					pixels[sp] = 0x00FFFFFF;
				} else if (a < 255) {
					aFP = (0x00FF0000 / a);
					pixels[sp] = ((a << 24)
							| (((((pixel & 0xFF0000) >> 16) * aFP) & 0xFF0000))
							| (((((pixel & 0x00FF00) >> 8) * aFP) & 0xFF0000) >> 8) | (((((pixel & 0x0000FF)) * aFP) & 0xFF0000) >> 16));
				}
				sp++;
			}
		}
	}

	/**
	 * Create a new ColorModel with it's alpha premultiplied state matching newAlphaPreMult.
	 * @param cm  The ColorModel to change the alpha premult state of.
	 * @param newAlphaPreMult  The new state of alpha premult.
	 * @return    A new colorModel that has isAlphaPremultiplied() equal to newAlphaPreMult.
	 */
	public static ColorModel coerceColorModel(ColorModel cm,
			boolean newAlphaPreMult) {
		if (cm.isAlphaPremultiplied() == newAlphaPreMult)
			return cm;
		WritableRaster wr = cm.createCompatibleWritableRaster(1, 1);
		return cm.coerceData(wr, newAlphaPreMult);
	}

	/**
	 * Standard prebuilt Linear_sRGB color model with no alpha 
	 */
	public final static ColorModel Linear_sRGB = new DirectColorModel(
			ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB), 24, 0x00FF0000,
			0x0000FF00, 0x000000FF, 0x0, false, DataBuffer.TYPE_INT);
	/**
	 * Standard prebuilt Linear_sRGB color model with unpremultiplied alpha.
	 */
	public final static ColorModel Linear_sRGB_Unpre = new DirectColorModel(
			ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB), 32, 0x00FF0000,
			0x0000FF00, 0x000000FF, 0xFF000000, false, DataBuffer.TYPE_INT);
}

//*********************REFACTORED CODE ****************
