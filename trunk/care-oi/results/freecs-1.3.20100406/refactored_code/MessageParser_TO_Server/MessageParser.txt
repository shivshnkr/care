/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * the command set is inside here
 */
package freecs.core;

import freecs.*;
import freecs.layout.*;
import freecs.util.logger.LogWriter;
import freecs.commands.AbstractCommand;
import freecs.commands.CommandSet;
import freecs.content.*;
import freecs.interfaces.*;

import java.nio.charset.Charset;
import java.nio.charset.UnmappableCharacterException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Vector;

/**
 * constructed with a sender (possible null) and a raw message, this
 * message-container is responsible for parsing the message. if the message
 * was parsed successfully, the apropriate flags get set and the parsing
 * thread decides what to do with this message.
 */
public class MessageParser implements IContainer {
	private MessageState	msgState;
	private ByteBuffer		bBuff = null;
	private HashMap<String, StringBuffer>			renderCache;
	private boolean			isHTTP11 = true;
	private CommandSet		cs;
	private RequestReader req;

	public MessageParser () {
		renderCache = new HashMap<String, StringBuffer> ();
		msgState = new MessageState(this);
		cs = CommandSet.getCommandSet ();
		clear ();
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	}
   public MessageParser (RequestReader r) {
      renderCache = new HashMap<String, StringBuffer> ();
      msgState = new MessageState(this);
      cs = CommandSet.getCommandSet ();
      clear ();
      req=r;
      if (TRACE_CREATE_AND_FINALIZE)
          log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
				Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
   }

	/**
	 * clear the state of this messagparser
	 */
	protected void clear () {
		msgState.clear();
		renderCache.clear ();
		isHTTP11 = true;
	}

	/**
	 * set the http/1.1-capability for this message
	 * @param b if true HTTP1.1 is enabled, if false it will be disabled
	 */
   public void setHTTP11 (boolean b) {
      isHTTP11 = b;
   }

	public void setConnectionBuffer (ConnectionBuffer cb) {
		msgState.cb = cb;
	}

   /**
    * set the target to the given String
    * @param target the target
    */
   public void setParam (String target) {
       msgState.param = target;
   }

   /**
    * set the target to the given String
    * @param target the target
    */

   public void setReason (String target) {
       msgState.reason = target;
   }

   
   public void setTargetGroup (Group target) {
       msgState.targetGroup = target;
   }

   /**
    * set the source of this message to the given String
    * @param source the source
   public void setSource (String source) {
      msgState.source = source;
   }
    */

   /**
    * set the sender of this message
    * @param s the user which sent this message
    */
   public void setSender (User s) {
      msgState.sender = s;
   }
   
   public void setUsercontext (User s) {
	  msgState.usercontext = s;
   }

	/**
	 * set the message
	 * @param msg the raw message
	 */
   public void setRawMessage (String msg) {
      msgState.msg = msg.trim ();
   }

   public MessageState getMessageState() {
       return msgState;
   }
	/**
	 * return the sender of this message
	 * @return the sender of this message
	 */
   public User getSender () {
      return msgState.sender;
   }

	/**
	 * interface contentcontainer deffines the following
	 * @return the ByteBuffer containing the bytes to send
	 */
   public ByteBuffer getByteBuffer () {
      if (bBuff != null) 
          bBuff.rewind ();
      return (bBuff);
   }

   /**
    * returns always false for this, because the message-window doesn't get closed
    * except the user loggs out
    */
   public boolean closeSocket () {
      return false;
   }

	/**
	 * checks if there is actual some content to send
	 * @return true if there is content to send, false if not
	 */
   public boolean hasContent () {
      return (bBuff != null && bBuff.limit () > 0);
   }

	/**
	 * set the messagetemplate which should be used
	 * @param tplName the name of the message-template
	 */
   public void setMessageTemplate (String tplName) {
      msgState.msgTemplate = tplName;
   }

	/**
	 * get the personalized message for this user
	 * @param u the user to personalize the message for
	 * @return the IContainer containing the personalized message
	 */
   public boolean addPersonalizedMessage (User u, ConnectionBuffer cb) {
      StringBuffer result = new StringBuffer ();
      TemplateSet ts = u.getTemplateSet ();
      StringBuffer tsb = new StringBuffer (ts.getName ()).append ("/").append (msgState.msgTemplate).append ("/").append (isHTTP11);
      String rcKey = tsb.toString ();
      // check if the wanted message is contained within the render-cache
      if (!USE_MESSAGE_RENDER_CACHE 
              || !msgState.useRenderCache 
              || !renderCache.containsKey (rcKey)) {
    	  boolean allowedParam = true;
          String msgTpl = ts.getMessageTemplate (msgState.msgTemplate);

    	  if (msgState.msgTemplate.startsWith("funcommand.")){
    			if (msgState.param.toLowerCase().indexOf("http://")>-1 || msgState.param.toLowerCase().indexOf("www.")>-1)
    				allowedParam = false;
    			if (msgTpl.toLowerCase().indexOf("<script")>-1 )
    				msgTpl = "<b>not allowed Index</b>";
    	  }
    	  
          if (!allowedParam)
        	  msgTpl = "<b>not allowed param</b>";
         
          if (msgTpl == null || msgTpl.length () < 1) {
              tsb = new StringBuffer ("Message-Template ").append (msgState.msgTemplate).append (" was not found ");
              log("[Templateset " + ts.getName() + "]", tsb.toString(),
					Server.MSG_ERROR, Server.LVL_MINOR);
              if (DEBUG_TEMPLATESET){
                  msgTpl = tsb.toString ();
                  result.append(msgTpl);
              } else return false;
          }
          String showTime = ts.getMessageTemplate ("status.showtime");
          if (showTime != null && (showTime.equals ("true") || showTime.equals("1"))) {
              String tf = ts.getMessageTemplate ("status.showtime.timeformat");
         	  if (tf != null) result.append (MessageRenderer.renderTemplate (msgState, tf, false));
         	  else {
         	     result.append ("[");
         	     result.append (srv.getFormatedTime ("HH:mm"));
         	     result.append ("] ");
         	  }
         }
         result.append (MessageRenderer.renderTemplate (msgState, msgTpl));
         renderCache.put (rcKey, result);
      } else {
         result.append (renderCache.get(rcKey));
      }
      if (result.length() < 1) return false;
      CharBuffer cbuf = CharBuffer.wrap (result);
      try {
      	if (cbuf.length() < 2) {
      		if (msgState.msgTemplate.equals ("message.q") 
                || msgState.msgTemplate.equals ("message.server.shutdown")
                || msgState.msgTemplate.equals ("message.kh.personal")) { 
                    msgState.sender.removeNow();
                    CentralSelector.dropKey(u.getKey());
            }
            return false;
      	}
        if ((msgState.msgTemplate.equals ("message.q") 
                || msgState.msgTemplate.equals ("message.server.shutdown")
                || msgState.msgTemplate.equals ("message.kh.personal"))) {
            cb.addToWrite(Charset.forName (DEFAULT_CHARSET).newEncoder ().encode (cbuf));
            cb.addToWrite(Responder.CLOSE_CONNECTION);
            return true;
        }
        cb.addToWrite(Charset.forName (DEFAULT_CHARSET).newEncoder ().encode (cbuf));
        return true;
      } catch (UnmappableCharacterException uce) {
         debug(this, "getPersonalizedMessage: ", uce, Server.MSG_ERROR,
				Server.LVL_MINOR);
         byte[] b = result.toString ().getBytes ();
         ByteBuffer bb = ByteBuffer.wrap (b);
         if ((msgState.msgTemplate.equals ("message.q") 
                 || msgState.msgTemplate.equals ("message.server.shutdown")
                 || msgState.msgTemplate.equals ("message.kh.personal"))) {
             cb.addToWrite(bb);
             cb.addToWrite(Responder.CLOSE_CONNECTION);
             return true;
         }
         cb.addToWrite(bb);
         return true;
      } catch (Exception e) {
         Server.debug (this, "getPersonalizedMessage: ", e, MSG_ERROR, LVL_MAJOR);
         return false;
      }
   }

   public boolean prepareForSending () {
      if (this.bBuff != null) return true;
      return false;
   }

/*   public void finalize () {
      Server.log ("MessageParser FINALIZED*******************************", Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
   } */

   /**
    *--------------------- MESSAGE-PARSING -------------------
    * this is where the parsing of the message happens.
    */
	public void parseAndSendMessage () {
		if (req!=null) req.currPosition = RequestReader.PARSE_MSG;
		if (msgState.msg == null 
			|| msgState.msg.length () < 1
			|| msgState.sender == null
			|| !msgState.cb.isValid()) {
			clear ();
			return;
		}
        // check message lenght
		if (MESSAGE_FLOOD_LENGHT > 0 
				&& (msgState.sender.getGroup().hasState(IGroupState.ENTRANCE) 
				|| msgState.sender.getGroup().hasState(IGroupState.CAN_SET_PUNISHABLE))) {
		    if (msgState.msg.length() >= MESSAGE_FLOOD_LENGHT){
			    if (msgState.sender.hasMessageFloodLenght()){
				    clear();
				    return;
			    }
            	srv.storeUser(IActionStates.ISPUNISHABLE, msgState.sender, msgState.reason, 60000, "Messagelenght");
			    msgState.sender.setMessageFloodLenght(true);
		    } else {
			    if (msgState.sender.hasMessageFloodLenght())
				    msgState.sender.setMessageFloodLenght(false);
		    }
		}
		// check if user was in away-state
		if (msgState.sender.isAway ()) {
			msgState.msgTemplate="message.away.off";
			msgState.message=msgState.sender.getAwayMessage();
			Group sg = msgState.sender.getGroup ();
			if (sg != null)
				sg.sendMessage (this);
			else
				msgState.sender.sendMessage (this);
			msgState.sender.setAway (false);
			Vector<Object> found = new Vector<Object>();
			Vector<Object> foundName = new Vector<Object>();
		    Vector<Object> added = msgState.sender.whisper();
		    for (Enumeration<Object> e = added.elements(); e.hasMoreElements(); ) {
		    	Object add = (Object)e.nextElement();
		    	String nick = null;
		    	if (add instanceof User){
		    	    User addu = (User) add;
		    	    nick = addu.getName();
		    	}
		    	if (nick != null){
		    	    if (!foundName.contains(nick)){
		    	        if (!found.contains(add)){
		                    found.add(add);
		                    foundName.add(nick);
		                }
		    	    }
		    	}	       		       
		    }
			if (found.size() >0) {
				if (found.size() == 1) {
					Object o= found.get(0);
	                if (o instanceof User) {
	                    msgState.usercontext = (User) o;
	                    msgState.param = "";
	                } else {
	                   msgState.usercontext = null;
	                   msgState.param = (String) o;
	                }
			        msgState.msgTemplate="message.away.whisper.singular";
				}
				if (found.size() > 1)
			        msgState.msgTemplate="message.away.whisper.plural";
			    Object size = msgState.sender.whisper().size();
			    
			    msgState.param = size.toString();
			    msgState.usrList = found.toArray();
			    msgState.sender.sendMessage (msgState.mp);
                Integer s = (Integer) size;
                msgState.sender.sendMessageHistory(s);
			}
//			 FriendNotification 
			Vector<Object> foundFriends = new Vector<Object>();
		    Vector<Object> storeFriendNotification = msgState.sender.getStoreFriendNotification();
		    
		    for (Enumeration<Object> e = storeFriendNotification.elements(); e.hasMoreElements(); ) {
		    	Object add = (Object)e.nextElement();
		    	if (add instanceof User) {
		    		User a= (User) add;
		    		if (UserManager.mgr.getUserByName(a.getName()) != null && a.getGroup() != null) {
			            if (!foundFriends.contains(add)) {
			        	    foundFriends.add(add);
			            }
		    		}		    	
		    	}
		    }
		    
		    if (foundFriends.size() >0) {
				if (foundFriends.size() == 1) {
					Object o= foundFriends.get(0);
	                if (o instanceof User) {
	                    msgState.usercontext = (User) o;
	                    msgState.param = "";
	                } else {
	                   msgState.usercontext = null;
	                   msgState.param = (String) o;
	                }
			        msgState.msgTemplate="message.away.friendnotification.singular";
				}
				if (foundFriends.size() > 1)
			        msgState.msgTemplate="message.away.friendnotification.plural";
			
			    msgState.usrList = foundFriends.toArray();
			    msgState.sender.sendMessage (msgState.mp);
			}
      	}

		if (!msgState.msg.startsWith ("/") || msgState.sender == null) {
			if (msgState.sender != null 
			        && msgState.sender.isPunished()) {
		        msgState.msgTemplate = "error.user.punished";
		        msgState.sender.sendMessage(msgState.mp);
				clear ();
				return;
			}
			Group sg = msgState.sender.getGroup ();
			int timelocksec = sg.getTimelockSec();
			if (msgState.sender.getGroup().hasState(IGroupState.MODERATED) 
                    && !msgState.sender.hasRight(IUserStates.IS_MODERATOR) 
                    && !msgState.sender.hasRight(IUserStates.IS_GUEST)) {
                // check the timelock if group is moderated and sender isn't guest nore moderator
				if (msgState.sender.lastSentMessage > System.currentTimeMillis() - 1 * timelocksec  * 1000) {
					msgState.msgTemplate = "error.moderated.timelock";
					msgState.param = "" + ((msgState.sender.lastSentMessage - System.currentTimeMillis() + (1 * timelocksec  * 1000)) / 1000);
					msgState.message = msgState.msg;
					msgState.sender.sendMessage(this);
					clear();
					return;
				} else {
					msgState.sender.lastSentMessage = System.currentTimeMillis();
					msgState.msgTemplate = "message.send.moderated";
					msgState.message = msgState.msg;
					msgState.sender.getGroup().sendMessage(this);
					msgState.msgTemplate = "message.send.moderated.personal";
					msgState.message = msgState.msg;
					msgState.sender.sendMessage(this);
					messageLog(msgState, null, null);
					clear();
					return;
				}
			} else {
				msgState.sender.lastSentMessage = System.currentTimeMillis();
				msgState.msgTemplate = "message.send";
				msgState.message = msgState.msg;
				msgState.sender.getGroup().sendMessage(this);
				AbstractCommand.messageLog(msgState, null, null);
				clear();
				return;
			}
				
		}

		if (req!=null) {
            req.currPosition = RequestReader.EVALUATE_COMMAND;
            req.currCommand = msgState.msg;
        }
		// retrieve the command-token
		int pos = msgState.msg.indexOf (" ");
		String cmd, param;
		if (pos > -1) {
			cmd = msgState.msg.substring(0,pos).toLowerCase();
			param = msgState.msg.substring (pos).trim ();
		} else {
			cmd = msgState.msg;
			param = "";
		}
        // "/.... text" is used for whispering to user ...
        if (param.length() > 0) {
            if (cmd.equals("/time")) {
                cmd = "/m";
                param = "time " + param;
            } else if (cmd.equals("/raq")) {
                cmd = "/m"  ;
                param = "raq " + param;
            } else if (cmd.equals("/mycol")) {
                cmd = "/m";
                param = "mycol " + param;
            } else if (cmd.equals("/fl")) {
                cmd = "/m";
                param = "fl " + param;
            } else if (cmd.equals("/a")) {
                cmd = "/m";
                param = "a " + param;
            } else if (cmd.equals("/l")) {
                cmd = "/m";
                param = "l " + param;
            } else if (cmd.equals("/ul")) {
                cmd = "/m";
                param = "ul " + param;
            }
        }
		byte result = cs.evaluate(cmd, msgState, param); 
		if (result == CommandSet.UNKNOWN_COMMAND) {
			cs.evaluate("/m", msgState, msgState.msg.substring (1));
		} else if (result==CommandSet.INTERRUPTED) {
			msgState.cb.logError("ConnectionBuffer was invalidated");
		}
		clear ();
	}
    
    private volatile String strgVal;
    public String toString () {
        if (strgVal==null) {
            StringBuffer sb = new StringBuffer("[MessageParser ");
            if (req != null)
                sb.append (this.req.toString());
            sb.append ("]");
        }
        return strgVal;
        
    }
    /**
     * @param msg
     */
    public void setMessage(String msg) {
        msgState.message = msg;
    }

    public void finalize() {
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "----------------------------------------FINALIZED",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
    }
	public static void messageLog(MessageState msgState, User cu, String Command) {
		StringBuffer name = new StringBuffer("[").append(
				msgState.sender.getName()).append("]");
		if (msgState.sender.getGroup().hasState(IGroupState.ENTRANCE)) {
			StringBuffer log = null;
			if (Command != null && Command.equals("Think")) {
				log = new StringBuffer("Think:").append(msgState.message);
				logMessage(msgState, name.toString(), log.toString(),
						Server.MSG_MESSAGE, Server.LVL_MAJOR);
			} else if (Command != null && Command.equals("SetTheme")) {
				log = new StringBuffer("SetTheme:").append(msgState.param);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_MESSAGE, LVL_MAJOR);
			} else if (Command != null && Command.equals("PrivatMessage")) {
				log = new StringBuffer("whisper to ").append("[")
						.append(cu.getName()).append("] (room: ")
						.append(cu.getGroup().getRawName()).append(") ")
						.append(msgState.message);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_MESSAGE, LVL_MAJOR);
			} else if (msgState.sender.isAway()
					&& msgState.sender.getAwayMessage() != null) {
				if (msgState.sender.getAwayMessage().length() > 0) {
					log = new StringBuffer("AwayReason: ")
							.append(msgState.sender.getAwayMessage());
					Server.logMessage(msgState, name.toString(),
							log.toString(), MSG_MESSAGE,
							LVL_MAJOR);
				}
			} else {
				log = new StringBuffer(msgState.message);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_MESSAGE, LVL_MAJOR);
			}
		} else {
			StringBuffer log = null;
			if (Command != null && Command.equals("Think")) {
				log = new StringBuffer("Think:").append(msgState.message);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_SEPAMESSAGE, LVL_MAJOR);
			} else if (Command != null && Command.equals("SetTheme")) {
				log = new StringBuffer("SetTheme:").append(msgState.param);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_SEPAMESSAGE, LVL_MAJOR);
			} else if (Command != null && Command.equals("PrivatMessage")) {
				log = new StringBuffer("whisper to ").append("[")
						.append(cu.getName()).append("] (room: ")
						.append(cu.getGroup().getRawName()).append(") ")
						.append(msgState.message);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_SEPAMESSAGE, LVL_MAJOR);
			} else if (msgState.sender.isAway()
					&& msgState.sender.getAwayMessage() != null) {
				if (msgState.sender.getAwayMessage().length() > 0) {
					log = new StringBuffer("AwayReason: ")
							.append(msgState.sender.getAwayMessage());
					Server.logMessage(msgState, name.toString(),
							log.toString(), MSG_SEPAMESSAGE,
							LVL_MAJOR);
				}
			} else {
				log = new StringBuffer(msgState.message);
				Server.logMessage(msgState, name.toString(), log.toString(),
						MSG_SEPAMESSAGE, LVL_MAJOR);
			}
		}
	}
	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}
	/**
	 * Debuging method configured by the loglevel mechanism
	 * @param prefix  to write before other stuff
	 * @param t  is the throwable to print the stacktrace from
	 * @param type  the type of message, konstants with MSG_ prefix are used here
	 * @param lvl  the level of atention to use here, konstants with LVL_ prefix are used here
	 */
	public static void debug(Object o, String prefix, Throwable t, short type,
			short lvl) {
		if (LOG_MASK[type].intValue() < lvl && !DEBUG)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(prefix);
		sb.append("\r\n");
		sb.append(t.toString());
		StackTraceElement ste[] = t.getStackTrace();
		for (int i = 0; i < ste.length; i++) {
			sb.append("\r\n    at ");
			sb.append(ste[i].getClassName());
			sb.append("(");
			sb.append(ste[i].getFileName());
			sb.append(":");
			sb.append(ste[i].getLineNumber());
			sb.append(")");
		}
		log(o, sb.toString(), type, lvl);
	}
	public static void logMessage(MessageState messageState, Object o,
			String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			sb.append("]");
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_MESSAGE && LOGFILE[MSG_MESSAGE].equals("console"))
					|| (type == MSG_SEPAMESSAGE)
					&& LOGFILE[MSG_MESSAGE].equals("console")) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addMessageLogMessage(messageState, type,
						sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}
	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static Server srv = null;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public static final short MSG_ERROR = 4;
	public static final short LVL_MINOR = 2;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public String DEFAULT_CHARSET = "iso-8859-1", TIMEZONE, ADMIN_HTTP_ALLOWED,
			ADMIN_XMLRPC_ALLOWED, DEFAULT_TEMPLATESET, DEFAULT_MEMBERSHIP;
	public static final short LVL_MAJOR = 1;
	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;
	public static boolean TRACE_CREATE_AND_FINALIZE = false;
	public static final short MSG_STATE = 2;
	public static final short LVL_VERY_VERBOSE = 4;
	public static final short MSG_MESSAGE = 5;
	public static final short MSG_SEPAMESSAGE = 6;
	public static Short LOG_MASK[] = new Short[7];
	public static boolean DEBUG = false;
	public static final short LVL_HALT = 0;
	public static final short MSG_CONFIG = 0;
	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };
	public static final short MSG_AUTH = 1;
	public static final short MSG_TRAFFIC = 3;
	public static Calendar cal = Calendar.getInstance();
	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
