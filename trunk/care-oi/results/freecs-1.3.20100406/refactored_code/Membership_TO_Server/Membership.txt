/**
 * Copyright (C) 2004 Manfred Andres
 * Created: 11.10.2004 (15:50:57)
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package freecs.core;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Iterator;
import java.util.Properties;
import java.util.Vector;

import freecs.Server;
import freecs.content.CallMembershipObject;
import freecs.interfaces.IContainer;
import freecs.interfaces.IMessageDestination;
import freecs.util.logger.LogWriter;


/**
 * @author Manfred Andres
 *
 * Representation of one single membership. Implements interface IMessageDestination
 * making it possible to send Messages to alle users belonging to this Membership.
 * @see freecs.interfaces#IMessageDestination
 */
public class Membership implements IMessageDestination {
    private Vector<Object> members = new Vector<Object>();
    
    public final String key;
    private volatile String namePrefix, nameSuffix, stringRepresentation, mayUseTemplateset;
    private volatile boolean displayDefaultVipRighttitle = false, displayDefaultModGuestTitle = true, listedAsOnlinevip = true;
    private volatile int addedStates = 0, removedStates = 0;
    private volatile int addedDefaultStates = 0, removedDefaultStates = 0;
    private volatile long userTimeout = 0;
    private volatile Vector<CallMembershipObject> callKey = new Vector<CallMembershipObject>();
    private volatile int privatemessageStore = 0;
    
    public Membership (String key, Properties p) {
        if (key == null)
            throw new RuntimeException ("unable to construct membership without key");
        this.key = key;
        if (p == null && !key.equals("undefined"))
            throw new RuntimeException ("unable to construct membership without properties");
        init(p);
    }

    private void init (Properties p) {
        if (p==null)
            return;
        boolean checkNamePrefix = false,checkNameSuffix = false,checkStringRepresentation = false,checkAddedStates = false
        ,checkRemovedStates = false,checkAddedDefaultStates = false,checkRemovedDefaultStates = false,
        checkDisplayDefaultVipRighttitle = false,checkDisplayDefaultModGuestTitle = false,checkListedAsOnlinevip = false,
        checkUserTimeout = false, checkMayUseTemplateset = false, checkPrivatemessageStore = false;
        for (Iterator<Object> i = p.keySet().iterator(); i.hasNext(); ) {
            String currKey = (String) i.next();
            if (currKey.equalsIgnoreCase ("usernameprefix")) {
                namePrefix = p.getProperty(currKey);
                checkNamePrefix = true;
            } else if (currKey.equalsIgnoreCase ("usernamesuffix")) {
                nameSuffix = p.getProperty(currKey);
                checkNameSuffix = true;
            } else if (currKey.equalsIgnoreCase ("stringrepresentation")) {
                stringRepresentation = p.getProperty(currKey);
                checkStringRepresentation = true;
            } else if (currKey.equalsIgnoreCase ("addstates")) {
                String val = p.getProperty(currKey);
                String[] states = val.split(",");
                addedStates = 0;
                for (int j = 0; j < states.length; j++) {
                    addedStates = addedStates | UserManager.resolveState(states[j]);
                }
                checkAddedStates = true;
            } else if (currKey.equalsIgnoreCase ("removestates")) {
                String val = p.getProperty(currKey);
                String[] states = val.split(",");
                removedStates = 0;
                for (int j = 0; j < states.length; j++) {
                    removedStates = removedStates | UserManager.resolveState(states[j]);
                }
                checkRemovedStates = true;
            } else if (currKey.equalsIgnoreCase ("adddefaultstates")) {
                String val = p.getProperty(currKey);
                String[] states = val.split(",");
                addedDefaultStates = 0;
                for (int j = 0; j < states.length; j++) {
                    addedDefaultStates = addedDefaultStates | UserManager.resolveState(states[j]);
                }
                checkAddedDefaultStates = true;
            } else if (currKey.equalsIgnoreCase ("removedefaultstates")) {
                String val = p.getProperty(currKey);
                String[] states = val.split(",");
                removedDefaultStates = 0;
                for (int j = 0; j < states.length; j++) {
                    removedDefaultStates = removedDefaultStates | UserManager.resolveState(states[j]);
                }
                checkRemovedDefaultStates = true;
            } else if (currKey.equalsIgnoreCase ("displaydefaultviprighttitle") 
                    && p.getProperty(currKey).equalsIgnoreCase ("true")) {
            	displayDefaultVipRighttitle = true;
            	checkDisplayDefaultVipRighttitle = true;
            } else if (currKey.equalsIgnoreCase ("displaydefaultmodguesttitle") 
                    && p.getProperty(currKey).equalsIgnoreCase ("false")) {
            	displayDefaultModGuestTitle = false;
            	checkDisplayDefaultModGuestTitle = true;
            } else if (currKey.equalsIgnoreCase ("listedasonlinevip") 
                    && p.getProperty(currKey).equalsIgnoreCase ("false")) {
            	listedAsOnlinevip = false;
            	checkListedAsOnlinevip = true;
            } else if (currKey.equalsIgnoreCase ("usertimeout")) {  
            	try {
            	    Integer o = new Integer(p.getProperty(currKey));
                    userTimeout = o.longValue();
            	} catch (NumberFormatException n) {
                    log("[Membership]", "clear userTimeout for Membership "
							+ this.getName() + " " + n, Server.MSG_ERROR,
							Server.LVL_MAJOR);
            		userTimeout = 0;
            	}
            	checkUserTimeout = true;
            } else if (currKey.equalsIgnoreCase ("mayusetemplateset")) {
                mayUseTemplateset = p.getProperty(currKey);
                checkMayUseTemplateset = true;
            } else if (currKey.equalsIgnoreCase ("privatemessageStore")) {  
                try {
                    Integer o = new Integer(p.getProperty(currKey));
                    privatemessageStore = o.intValue();
                } catch (NumberFormatException n) {
                    privatemessageStore = 0;
                    Server.log("[Membership]", "clear privatemessageStore for Membership "+this.getName()+" "+n, MSG_ERROR, LVL_MAJOR);
                }
                checkPrivatemessageStore = true;
            }
        }
        
        if (!checkNamePrefix)
        	namePrefix = null;
        if (!checkNameSuffix)
        	nameSuffix = null;
        if (!checkStringRepresentation)
        	stringRepresentation = null;
        if (!checkAddedStates)
        	addedStates = 0;
        if (!checkRemovedStates)
        	removedStates = 0;
        if (!checkAddedDefaultStates)
        	addedDefaultStates = 0;
        if (!checkRemovedDefaultStates)
        	removedDefaultStates = 0;
        if (!checkDisplayDefaultVipRighttitle)
        	displayDefaultVipRighttitle = false;
        if (!checkDisplayDefaultModGuestTitle)
        	displayDefaultModGuestTitle = true;
        if (!checkListedAsOnlinevip)
        	listedAsOnlinevip = true;
        if (!checkUserTimeout)
        	userTimeout = 0; 
        if (!checkMayUseTemplateset)
        	mayUseTemplateset = null;
        if (!checkPrivatemessageStore)
            privatemessageStore = 0;
    }

    public synchronized void update (Properties p) {
        init(p);
        for (Iterator<Object> i = members.iterator(); i.hasNext(); ) {
            User u = (User) i.next();
            u.rebuildMemberships();
        }
    }
    
    public void add (User u) {
        u.addMembership (this.key, this);
        
        // add addedStates and remove removedStates to/from this users permissionmap
        int pMap = u.getPermissionMap();
        pMap = pMap | addedStates;
        pMap = pMap - (pMap & removedStates);
        log("[" + this.key + "]",
				"setting user-state-map for user " + u.getName() + " to value "
						+ pMap, Server.MSG_AUTH, Server.LVL_VERY_VERBOSE);
        u.setPermission(pMap);
        
        int dpMap = u.getDefaultMembershipPermissionMap();
        dpMap = dpMap | addedDefaultStates;
        dpMap = dpMap - (dpMap & removedDefaultStates);
        Server.log ("["+this.key+"]", "setting user-defaultmembership-state-map for user " + u.getName() + " to value " + dpMap, MSG_AUTH, LVL_VERY_VERBOSE);
        u.setDefaultMembershipPermission(dpMap);
        
        if (dpMap >0 && dpMap != pMap) {
        	Server.log ("["+this.key+"]", "setting user-defaultstate-map for user " + u.getName() + " to value " + dpMap, MSG_AUTH, LVL_VERY_VERBOSE);
        	u.setDefaultPermissionMap(dpMap);
        }
        if (mayUseTemplateset != null)
            u.mayUseTemplateset(mayUseTemplateset);
    }
    
    public void remove (User u) {
        members.remove(u);
        if (members.size() == 0){
            callKey = new Vector<CallMembershipObject>();
            log(this.key, "reset callkey for Membership " + this.key,
					Server.MSG_STATE, Server.LVL_VERBOSE);
        } 
    }
    
    public void addToList(User u){
        if (!members.contains(u))
            members.add(u);
    }
    
    public void cleanup () {
        for (Iterator<Object> i = members.iterator(); i.hasNext(); ) {
            User u = (User) i.next();
            u.removeMembership(this.key);
        }
    }
    
    
    // Interface IMessageDestination
    
    /**
     * Send a message to all users having this membership
     * @see freecs.interfaces.IMessageDestination#sendMessage(freecs.interfaces.IContainer)
     */
    public void sendMessage(IContainer mc) {
        User[] uArr = (User[]) members.toArray(new User[0]);
        for (int i = 0; i < uArr.length; i++) {
            uArr[i].sendMessage(mc);
        }
    }

    public void sendHistory(User u){
        for (Iterator<CallMembershipObject> c = callKey.iterator(); c.hasNext();) {
            CallMembershipObject ca = (CallMembershipObject) c.next();
            MessageParser mp = new MessageParser();
            mp.setMessageTemplate("message.mcall.history");
            mp.setUsercontext(ca.cu);
            mp.setMessage(ca.message);
            mp.setParam(ca.param);
            u.sendMessage(mp);
        }
    }
    
    public synchronized void addCallKey(CallMembershipObject cm){
        callKey.add(cm);     
        int max = MAX_MCALL_KEY;
        int diff = callKey.size()-max;
        if (diff > 0){
            int i = 0;
            Vector<CallMembershipObject> tmp = new Vector<CallMembershipObject>(callKey);
            for (Iterator<CallMembershipObject> c = tmp.iterator(); i<=diff;) {
                CallMembershipObject ca = (CallMembershipObject) c.next();
                i++;
                callKey.remove(ca);             
            }
        }                    
    }

    /**
     * Iterator over all users having this membership
     * @see freecs.interfaces.IMessageDestination#users()
     */
    public Iterator<Object> users() {
        return members.iterator();
    }

    /**
     * return the name of this membership
     * @see freecs.interfaces.IMessageDestination#getName()
     */
    public String getName() {
        if (stringRepresentation != null)
            return stringRepresentation;
        return key;
    }
    
    public String getNamePrefix() {
    		return namePrefix;
    }
    
    public String getNameSuffix() {
    		return nameSuffix;
    }
    
    public boolean displayDefaultVipRighttitle() {
    	return displayDefaultVipRighttitle;
    }
    
    public boolean displayDefaultModGuesttitle() {
    	return displayDefaultModGuestTitle;
    }
    
    public boolean listedAsOnlinevip() {
    	return listedAsOnlinevip;
    }
    
    public long userTimeout() {
    	return userTimeout;
    }
    
    public String mayUseTemplateset(){
    	return mayUseTemplateset;
    }
    
    public int getPrivatemessageStore() {
        return privatemessageStore;
    }

    public int hashCode() {
        return key.hashCode();
    }
    
    public boolean equals (Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Membership))
            return false;
        Membership foreign = (Membership) o;
        return foreign.key.equals(this.key);
    }
    
    public String toString() {
        return this.stringRepresentation;
    }

	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}

	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static final short MSG_ERROR = 4;

	public static final short LVL_MAJOR = 1;

	public static final short MSG_AUTH = 1;

	public static final short LVL_VERY_VERBOSE = 4;

	public static final short MSG_STATE = 2;

	public static final short LVL_VERBOSE = 3;

	public static Server srv = null;

	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;

	public static Short LOG_MASK[] = new Short[7];

	public static boolean DEBUG = false;

	public static final short LVL_HALT = 0;

	public static final short MSG_CONFIG = 0;

	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };

	public static final short MSG_TRAFFIC = 3;

	public static Calendar cal = Calendar.getInstance();

	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
