/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package freecs.core;

import freecs.*;
import freecs.content.*;
import freecs.interfaces.*;
import freecs.util.ObjectBuffer;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import freecs.util.TrafficMonitor;
import freecs.util.logger.LogWriter;
import java.net.InetAddress;
import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * gets attached to the keys reading from a nonblocking channel
 * stores the raw request in a buffer. if the request is finished, parse gets
 * called which in turn decides which requestobject to use for this requst
 * and suplies this RequestObject to the next available RequestEvaluator
 */
public class ConnectionBuffer {
   private volatile User u;
   private int src;
   private ByteBuffer buf;
   private ByteBuffer tBuf = null;
   public  ByteBuffer rBuf = ByteBuffer.allocate (Server.srv.READBUFFER_SIZE);
   private SelectionKey sk;
   private String ts;
   private ObjectBuffer writeBuffer = new ObjectBuffer (Server.srv.INITIAL_RESPONSE_QUEUE);
   private volatile boolean valid=true;
   public Connection conn;

   private StringBuffer lsb = new StringBuffer();
   
   private static final int GET = 1;
   private static final int POST= 2;

   private int reqType = 0;
   private int so = 0;
   private int cStart   = -1;
   private int cLength  = -1;
   public volatile IRequest currentRequest;
   private boolean reading=false;
   
    private volatile long closeWhen=System.currentTimeMillis() + Server.srv.KEEP_ALIVE_TIMEOUT;


   public ConnectionBuffer (int src) {
      this.src = src;
      buf = ByteBuffer.allocate(READBUFFER_SIZE);
      if (TRACE_CREATE_AND_FINALIZE)
          log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
				Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
   }

	/**
	 * appends to the incomplete request and checks if it has completed
	 * if the request is complete, it will be returned. NULL will be returned
	 * on the other hand.
	 * FIXME: has to get more modular to support different protocols
	 * @return IRequst The full request || null if incomplete
	 */
    public IRequest append () throws Exception {
        boolean parse = false;
        synchronized (this) {
            reading=true;
            rBuf.flip();
            if (this.buf.remaining () < rBuf.remaining ()) {
                ByteBuffer tbuf = ByteBuffer.allocate (this.buf.position () + rBuf.remaining ());
                this.buf.flip ();
                tbuf.put(this.buf);
                this.buf = tbuf;
            }
            this.buf.put(rBuf);
            rBuf.clear ();
            if (reqType == 0 && this.buf.position () > 4) {
                if (this.buf.get(0) == 'P' && this.buf.get(1) == 'O' && this.buf.get(2) == 'S' && this.buf.get(3) == 'T') {
                    reqType = POST;
                } else if (this.buf.get(0) == 'G' && this.buf.get(1) == 'E' && this.buf.get(2) == 'T') {
                    reqType = GET;
                } else {
                    this.addLog("HEADER-INVALID");
                    this.invalidate();
                    reading=false;
                    return null;
                }
            }
            if (reqType == GET) {
                if (this.buf.position() > 4096) {
                    this.addLog("HEADER>4096bytes");
                    this.invalidate();
                    reading=false;
                    return null;
                }
                if (this.buf.position () > 10 
                    && this.buf.get (this.buf.position () - 4) == '\r'
                    && this.buf.get (this.buf.position () - 3) == '\n'
                    && this.buf.get (this.buf.position () - 2) == '\r'
                    && this.buf.get (this.buf.position () - 1) == '\n') {
                        parse = true;
                }
            } else if (reqType == POST) {
                if (cLength == -1) {
                    for (; so < this.buf.position () - 15; so++) {
                        if (so > 4096 
                            || (this.buf.get(so)   == '\r' 
                                && this.buf.get(so+1) == '\n' 
                                && this.buf.get(so+2) == '\r'
                                && this.buf.get(so+3) == '\n')) {
                            this.addLog("HEADER-INVALID");
                            this.invalidate();
                            reading=false;
                            return null;
                        }
                        if (this.buf.get(so) == 'C' && this.buf.get(so+1) == 'o' 
                                && this.buf.get(so+2) == 'n' && this.buf.get(so+3) == 't' 
                                && this.buf.get(so+4) == 'e' && this.buf.get(so+5) == 'n' 
                                && this.buf.get(so+6) == 't' && this.buf.get(so+7) == '-' 
                                && (this.buf.get(so+8) == 'L' || this.buf.get(so+8) == 'l')
                                && this.buf.get(so+9) == 'e' && this.buf.get(so+10) == 'n' 
                                && this.buf.get(so+11) == 'g' && this.buf.get(so+12) == 't' 
                                && this.buf.get(so+13) == 'h' && this.buf.get(so+14) == ':') {
                            int cso = so + 14;
                            if (cso >= this.buf.capacity ()) return null;
                            while ((this.buf.get(cso) < 48 || this.buf.get(cso) > 57)) {
                                if (cso >= this.buf.capacity ()) return null;
                                cso++;
                            }
                            StringBuffer sb = new StringBuffer ();
                            while (this.buf.get(cso) >= 48 && this.buf.get(cso) <= 57) {
                                if (cso >= this.buf.capacity ()) return null;
                                sb.append ((char) this.buf.get(cso));
                                cso++;
                            }
                            so = cso;
                            cLength = Integer.parseInt (sb.toString ());
                            break;
                        }
                    }
                }
                if (cLength != -1) {
                    for (; cStart == -1 && so < this.buf.position () - 4; so++) {
                        if (so > 4096) {
                            this.addLog("HEADER>4096bytes");
                            this.invalidate();
                            reading=false;
                            return null;
                        }
                        if (this.buf.get(so)   == '\r' 
                                && this.buf.get(so+1) == '\n' 
                                && this.buf.get(so+2) == '\r'
                                && this.buf.get(so+3) == '\n') {
                            cStart = so + 4;
                            break;
                        }
                    }
                    if (cStart != -1) {
                        if ((this.buf.position () - cStart) > cLength) {
                            int diff = this.buf.position () - cStart - cLength;
                            tBuf = ByteBuffer.allocate (diff);
                            for (int pos = this.buf.position () - diff; pos < this.buf.position (); pos++) {
                                tBuf.put (this.buf.get (pos));
                            }
                            this.buf.position(cStart + cLength);
                            parse=true;
                        } else if ((this.buf.position () - cStart) == cLength) {
                            parse=true;
                        }
                    }
                }
            }
        }
        if (parse) 
            return parse();
        return null;
    }

	/**
	 * hands over this buffer to the requestparser-threads which take care of parsing the request
	 * @return IRequest The IRequest-object containing the request
	 */
    public IRequest parse () throws Exception {
        // FIXME: when we install another protocol we have to check here for the type of protocol
        IRequest req = null;
        synchronized (this) {
            this.buf.flip ();
            try {
                req = new HTTPRequest(buf, this);
            } catch (Exception e) {
                reset();
                throw e;
            }
            reading=false;
        }
        try {            
            req.parse ();
            Connection conn = req.getConnectionObject();
            if (!conn.isDirectlyConnected) {
                InetAddress ia = ((SocketChannel) sk.channel ()).socket().getInetAddress ();
                if (ia != null) {
                    TrafficMonitor.tm.markAsProxy (ia);
                }
            }
/*        } catch (Exception e) {
            Server.debug (this, "parse: ", e, Server.MSG_ERROR, Server.LVL_MAJOR);
            throw e; */
        } finally {
            reset ();
        }
        return req;
    }

	private synchronized void reset () {
      if (buf.capacity () != READBUFFER_SIZE) {
         buf = ByteBuffer.allocate (READBUFFER_SIZE);
      } else {
         buf.clear ();
      }
      if (tBuf != null) {
         buf.put (tBuf);
         tBuf = null;
      }
      cStart = -1;
      cLength= -1;
      reqType= 0;
      so = 0;
      valid=true;
      reading=false;
   }

   public void setTemplateSet (String ts) {
      this.ts = ts;
   }

   public String getTemplateSet () {
      return ts;
   }

   public void setUser (User u) {
      this.u = u;
   }

   public User getUser () {
      return u;
   }

    /**
    * returns the SocketChannel of this requestbuffer
    */
   public SelectionKey getKey () {
      return sk;
   }
	
	public void setKey (SelectionKey sk) {
        if (!CentralSelector.isSkValid(sk)) {
            log(this, "setKey: tryed to set invalid key", Server.MSG_STATE,
					Server.LVL_VERBOSE);
            return;
        }
		this.sk=sk;
		conn = new Connection (sk);
	}

	public void addToWrite (Object ic) {
        if (!CentralSelector.isSkValid(sk)) {
            log(this, "addToWrite: selection-key isn't valid anymore",
					Server.MSG_STATE, Server.LVL_VERBOSE);
            return;
        }
        synchronized (this) {
            if (writeBuffer.isFull ()) {
                int newSize = writeBuffer.capacity () + INITIAL_RESPONSE_QUEUE; 
                if (newSize > MAX_RESPONSE_QUEUE) {
                    Server.log(this, "addToWrite: write-queue would be bigger than specified for " + toString(), MSG_STATE, LVL_MINOR);
                    return;
                }
                Server.log(this, "addToWrite: Expanding write-queue for " + toString(), MSG_STATE, LVL_MINOR);
                writeBuffer.resizeTo(newSize);
            }
            writeBuffer.put(ic);
        }
        writeToLog();
		Responder.res.addToWrite((SocketChannel) sk.channel(), this);
	}

	public ObjectBuffer getWriteQueue () {
		return writeBuffer;
	}

	public void updateKeepAliveTimeout () {
		if (isMessageFrame)
			return;
		closeWhen = System.currentTimeMillis() + KEEP_ALIVE_TIMEOUT;
	}
    
    public long getKeepAliveTimeout(long ts) {
        if (isMessageFrame || reading)
            return -1;
        return closeWhen;
    }
	
	public void invalidate() {
		valid=false;
	}
	
	public boolean isValid() {
		return valid;
	}
	
	private volatile boolean isMessageFrame = false;
	public void setIsMessageFrame(boolean b) {
		// Server.log("changed state to message-frame-state", Server.MSG_STATE, Server.LVL_MAJOR);
		isMessageFrame=b;
	}
    
    public void addLog (String str) {
        lsb.append (" ");
        lsb.append (str);
    }

    public void writeToLog () {
        if (lsb.length() < 1)
            return;
        if (conn!=null && conn.peerAddress != null)
            lsb.insert(0, conn.peerAddress.getHostAddress());
        else if (conn != null)
            lsb.insert(0, conn.toString());
        else
            lsb.insert(0, "undefined");
        log("OK", lsb.toString(), Server.MSG_TRAFFIC, Server.LVL_MINOR);
        lsb = new StringBuffer();
    }

    public void logError (String reason) {
        lsb.append (" REASON: ");
        lsb.append (reason);
        if (conn != null && conn.peerAddress != null)
            lsb.insert (0, conn.peerAddress.getHostAddress());
        else if (conn != null)
            lsb.insert (0, conn.toString());
        else
            lsb.insert (0, "undefined");
        log("FAILED", lsb.toString(), Server.MSG_TRAFFIC, Server.LVL_MAJOR);
        lsb = new StringBuffer();
    }

    public void finalize() {
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "----------------------------------------FINALIZED",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
    }

	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}

	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static Server srv = null;
	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;
	public static final short MSG_STATE = 2;
	public static final short LVL_VERBOSE = 3;
	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;
	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;
	public static final short LVL_MINOR = 2;
	public long KEEP_ALIVE_TIMEOUT;
	public static final short MSG_TRAFFIC = 3;
	public static final short LVL_MAJOR = 1;
	public static boolean TRACE_CREATE_AND_FINALIZE = false;
	public static final short LVL_VERY_VERBOSE = 4;
	public static Short LOG_MASK[] = new Short[7];
	public static boolean DEBUG = false;
	public static final short LVL_HALT = 0;
	public static final short MSG_CONFIG = 0;
	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };
	public static final short MSG_AUTH = 1;
	public static final short MSG_ERROR = 4;
	public static Calendar cal = Calendar.getInstance();
	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
