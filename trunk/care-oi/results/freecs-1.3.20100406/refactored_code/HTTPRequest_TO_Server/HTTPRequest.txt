/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package freecs.content;

import freecs.*;
import freecs.core.*;
import freecs.util.CookieGenerator;
import freecs.util.EntityDecoder;
import freecs.util.logger.LogWriter;
import freecs.interfaces.*;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Properties;
import java.util.Enumeration;
import java.util.Vector;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.charset.Charset;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.MalformedInputException;
import java.net.InetAddress;
import java.net.URLDecoder;
import java.net.UnknownHostException;

/**
 * implementation of a HTTP-Request
 * parses the http-header and stores the neccesary data
 * as properties which may be accessed by the getProperty-Method
 */
public class HTTPRequest implements IRequest {
	private final SelectionKey key;
    private String request;
	private Properties 			props;
    private byte method;
	private String 				action, cookie, userAgent, url, cookieDomain;
	private boolean 			isHTTP11, refererFound;
	private final ConnectionBuffer 	cb;
//	private Properties			cookies = null;

	private Connection			conn;

   public HTTPRequest (ByteBuffer buf, ConnectionBuffer cb) throws CharacterCodingException {
      this.cb = cb;
      this.key = cb.getKey ();
      try {
          Charset c = Charset.forName("iso-8859-1");
          CharsetDecoder ce = c.newDecoder();
          CharBuffer cbuf = ce.decode(buf);
          this.request = cbuf.toString();
          // this.request = Charset.forName ().newDecoder ().decode (buf).toString();
      } catch (MalformedInputException mie) {
          this.request = new String(buf.array());
      }
      if (TRACE_CREATE_AND_FINALIZE)
          log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
				Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
   }

   public ConnectionBuffer getConnectionBuffer () {
      return cb;
   }

   /**
    * parses the HTTP request
    */
   public void parse () throws Exception {
       if (!CentralSelector.isSkValid(key)) {
           throw new Exception ("Key isn't valid anymore");
       }
      props = new Properties ();

      String parts[] = request.split ("\r\n\r\n");
      String hf[] = parts[0].split ("\r\n");

      String values[] = hf[0].split (" ");
      if ("GET".equals(values[0])) {
          method=METHOD_GET;
      } else if ("POST".equals(values[0])) {
          method=METHOD_POST;
      }
      action=parseAction(values[1]);
      isHTTP11 = values[2].equals ("HTTP/1.1") && USE_HTTP11;
      if (!isHTTP11 && parts.length > 1 && parts[1].substring (parts[1].length () - 2).equals ("\r\n")) {
         // it looks like http/1.0 has an extra \r\n after the values of a post-request (not included in content length)
         parts[1] = parts[1].substring (0, parts[1].length () - 2);
      }

      int pos = action.indexOf ("?");
      if (pos > -1) {
         String rest = action.substring (pos + 1);
         action = action.substring (0, pos);
         String prt[] = rest.split("&");
         for (int i = 0; i < prt.length; i++) {
             String keyval[] = prt[i].split ("=");
             if (keyval.length < 2) continue;
             keyval[0] = URLDecoder.decode(keyval[0], "UTF-8");
             try {
                keyval[1] = URLDecoder.decode(keyval[1].trim (), DEFAULT_CHARSET);
             } catch (IllegalArgumentException ie){
                 log(this, keyval[0] + "=" + keyval[1] + " URLDecoder.decode :"
						+ ie, Server.MSG_ERROR, Server.LVL_MAJOR);
                 continue;
             }
             StringBuffer tsb = new StringBuffer ("v_").append (keyval[0].trim ());
             props.setProperty (tsb.toString (), keyval[1]);
         }
      }
      refererFound = false;
      boolean isProxyConnection = false;
      String[] fwChain = null;
      String realIp = null;
      for (int i = 1; i < hf.length; i++) {
         int dp = hf[i].indexOf (":");
         if (dp == -1) continue;
         String key = hf[i].substring (0, dp).trim ().toLowerCase();
         String value = hf[i].substring (dp +1).trim ();
         if (key.equals ("host")) {
         	String hst = value.split (":")[0];
            InetAddress ia;
            try {
                ia = InetAddress.getByName (hst);
            } catch (UnknownHostException uhe) {
                Server.log (this, "Unable to lookup host specified in host-http-field a client claimed to get a resource from: '" + hst + "'", MSG_ERROR, LVL_MAJOR);
                throw uhe;
            }
            if (!"localhost".equalsIgnoreCase(hst) && STRICT_HOST_BINDING) {
            	boolean isServername = false;           	
                if (SERVER_NAME != null) {
                	StringBuffer tsb = new StringBuffer();
                	int c = 0;
                	for (Enumeration<String> e = SERVER_NAME.elements(); e.hasMoreElements(); ) {
            			String sv = (String) e.nextElement();
            			if (hst.equalsIgnoreCase(sv)){
            				StringBuffer sb =new StringBuffer(hst);
            				String port = props.getProperty("mappedPort");
            		        if (port==null)
            		            port = props.getProperty("port");
            		        if (!"80".equals(port)) {
            		    		sb.append(":");
            		    		sb.append(port);
            		        }
            			    url = sb.toString();
            			    if (COOKIE_DOMAIN == null){
                                Server.log("[HTTPRequest]","cookieDomain not configured", MSG_CONFIG, LVL_HALT);     
            			    }
            			    String cd[] = COOKIE_DOMAIN.toString().split(",");        
            			    if (cd[c].trim().toLowerCase() != null){
            			        cookieDomain= cd[c].trim().toLowerCase();
                                Server.log("[HTTPRequest]","cookieDomain = "+cookieDomain, MSG_TRAFFIC, LVL_VERY_VERBOSE);
                            } else {
                                Server.log("[HTTPRequest]","cookieDomain not configured", MSG_ERROR, LVL_MAJOR);	
                            }
                            isServername = true;
                            break;
            			}
                	    if (!hst.equalsIgnoreCase(sv)) {
                            tsb.append ("Recieved request specifying a different Host than specifiec inside configuration of this server. Recieved: ");
                            tsb.append (hst);
                            tsb.append (" Configured: ");
                            tsb.append (sv);
                        }
                	    c++;               	    
                	}
                	if (!isServername)
                		throw new Exception (tsb.toString());
                }
                if (!ia.equals (lh)) {               	
                	boolean isServer = false;
                	for (Enumeration<String> le = SERVER_NAME.elements(); le.hasMoreElements(); ) {
            			String sv = (String) le.nextElement();
            			if (hst.equalsIgnoreCase(sv)) {
            				isServer=true;
            				break;
            			}
                	    
                	}
                	if (!isServer){
                		StringBuffer tsb = new StringBuffer ("Recieved request specifying a host, which doesn't resolve to the host of this chat-server. Recieved: ");
                        tsb.append (hst);
                        throw new Exception (tsb.toString ());
                	}
                }
                if (COOKIE_DOMAIN != null) {
                	boolean isCookieDomain =false;
                	StringBuffer tsb = new StringBuffer();
                	String cd[] = COOKIE_DOMAIN.toString().split(",");
                    for (int co = 0; co < cd.length; co++) {
                         String c =(cd[co].trim().toLowerCase());           			     
            			 if (hst.endsWith(c)){
            			     isCookieDomain =true;
            			     break;
            			 }
            			 if (!hst.endsWith (c)){
            				 tsb.append("Wrong adress used: " + hst + " instead of something ending with " + c);
            			 }
                	}
                    
                	if (!isCookieDomain)
                	    throw new Exception (tsb.toString());
                	
                }
            }
        } else if (!ALLOW_EXTERNAL && key.equals ("referer")) {
        	value = value.substring(7);
        	int pos1=value.indexOf (":");
        	int pos2= value.indexOf ("/");
        	if (pos1 > 0 && pos1<pos2)
    		    pos2 = pos1;
        	if (pos2 > 0)
               value = value.substring (0,pos2);
               	
        	for (Enumeration<InetAddress> e = allowedLoginHosts.elements (); e.hasMoreElements (); ) {
      	        InetAddress ia = null;
      	    	try {
      	    	    ia = InetAddress.getByName (value.toString());
                  } catch (UnknownHostException uhe) {
						Server.log("[HTTPRequest]", "UnknownHostException: "+uhe, MSG_ERROR, LVL_MAJOR);
			            Server.log("[HTTPRequest]", "Referer "+ value + " not found " + "Url: " + url, MSG_ERROR, LVL_MAJOR);
						break;
                  }
                  if (ia!=null)
                      if (((InetAddress) e.nextElement ()).equals (ia)) {
                          refererFound = true;
                          break;
                      }
      	    }
        	if (!refererFound)
                Server.log("Referer ",value +" not found", MSG_TRAFFIC, LVL_VERBOSE);
         } else if (key.equals ("cookie")) {
            String cookiePair[] = value.split (";");
            for (int j = 0; j < cookiePair.length; j++) {
                String cp[] = cookiePair[j].trim().split ("=");
                if (cp.length < 2) 
                    continue;
                if (!cookiePair[j].trim ().startsWith("FreeCSSession")) {
                    props.put("c_" + cp[0], cp[1]);
                    continue;
                } 
               cookie = cp[1].trim ();
               if (!checkValidity(cookie)) {
               	  cookie = null;
               }
            }
         } else if (key.equalsIgnoreCase ("x-forwarded-for")) {
         	isProxyConnection = true;
         	fwChain = value.split(",");
		 } else if (key.equalsIgnoreCase ("via")) {
		 	isProxyConnection = true;
		 } else if (key.equalsIgnoreCase ("client-ip")) {
		 	isProxyConnection = true;
		 	realIp = value;
		 } else if (key.equals("user-agent")) {
		 	userAgent = value;
         } else {
			props.setProperty (key, value);
         }
      }
      conn = new Connection (this.key, fwChain, !isProxyConnection);
      if (realIp != null) try {
      	 InetAddress realAddress = InetAddress.getByName(realIp);
      	 conn.clientAddress = realAddress;
      	 conn.clientIp = realIp;
      } catch (UnknownHostException uhe) {
      	 debug(this, "parse: Headerfield client-IP contains an UnknownHost",
				uhe, Server.MSG_STATE, Server.LVL_MINOR);
      }
      if (parts.length < 2 ) return;
      hf = parts[1].split ("&");
      for (int i = 0; i < hf.length; i++) {
         String pair[] = hf[i].split ("=");
         if (pair.length < 2) continue;
         pair[0] = EntityDecoder.entityToChar (pair[0]);
         if (pair[0].equalsIgnoreCase ("message"))
            pair[1] = EntityDecoder.entityToHtml (pair[1].trim ());
         else
            pair[1] = EntityDecoder.entityToChar (pair[1].trim ());
         StringBuffer tsb = new StringBuffer ("v_").append (pair[0]);
         props.setProperty (tsb.toString (), pair[1]);
      }
   }

   /**
    * get properties of this request
    * @param key the name of this property
    * @return the value of the property identified by this key
    */
   public String getProperty (String key) {
      return props.getProperty (key);
   }
   
   public String getValue (String key) {
       return getProperty ("v_" + key);
   }
   
   private String parseAction (String rawAction) {
       if (rawAction.length() < 1
               || !rawAction.startsWith("http://"))
           return rawAction;
       int idx = rawAction.indexOf("/", 7);
       return rawAction.substring(idx);
   }
   
   public String getCookie (String key) {
       return getProperty ("c_");
   }
   
   public String getUrl(){
	   return url;
   }
   
   public String getCookieDomain(){
       log("[HTTPRequest]", "getCookieDomain = " + cookieDomain,
			Server.MSG_TRAFFIC, Server.LVL_VERY_VERBOSE);
	   return cookieDomain;
   }
   
   public byte getMethod () {
      return method;
   }
   public String getAction () {
      return action;
   }
   public boolean isHTTP11 () {
      return isHTTP11;
   }
   public String getCookie () {
      return cookie;
   }
   public String getUserAgent() {
   	  return userAgent;
   }
   public String getProtokol () {
      return isHTTP11 ? "HTTP/1.1" : "HTTP/1.0";
   }

	public Connection getConnectionObject() {
		return conn;
	}
	

   public SelectionKey getKey () {
      return key;
   }

   public boolean foundReferer(){
       return refererFound;
   }

   public String toString () {
       return "HTTP: " + action;
   }
   
/*    public String toString () {
        StringBuffer sb = new StringBuffer("[HTTPRequest: ");
        sb.append (method);
        sb.append (" ");
        sb.append (action);
        sb.append (" (");
        sb.append (cookie);
        sb.append (")@");
        if (conn != null) 
            sb.append (conn.toString());
        else
            sb.append ("unspeciefied");
        sb.append ("]");
        return sb.toString();
    } */

    public void finalize() {
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "----------------------------------------FINALIZED",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
    }

	/**
	 * Ceckfunction to check the validity of a FreeCS-Cookie FIXME: has to get better (e.g. include ip-address)
	 * @param cookie
	 * @return  boolean true if cookie is valid, false if not
	 */
	public static boolean checkValidity(String cookie) {
		if (cookie == null || cookie.length() != COOKIE_LENGTH)
			return false;
		return true;
	}

	private static int COOKIE_LENGTH = 32;

	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Debuging method configured by the loglevel mechanism
	 * @param prefix  to write before other stuff
	 * @param t  is the throwable to print the stacktrace from
	 * @param type  the type of message, konstants with MSG_ prefix are used here
	 * @param lvl  the level of atention to use here, konstants with LVL_ prefix are used here
	 */
	public static void debug(Object o, String prefix, Throwable t, short type,
			short lvl) {
		if (LOG_MASK[type].intValue() < lvl && !DEBUG)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(prefix);
		sb.append("\r\n");
		sb.append(t.toString());
		StackTraceElement ste[] = t.getStackTrace();
		for (int i = 0; i < ste.length; i++) {
			sb.append("\r\n    at ");
			sb.append(ste[i].getClassName());
			sb.append("(");
			sb.append(ste[i].getFileName());
			sb.append(":");
			sb.append(ste[i].getLineNumber());
			sb.append(")");
		}
		log(o, sb.toString(), type, lvl);
	}

	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static Server srv = null;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public String DEFAULT_CHARSET = "iso-8859-1", TIMEZONE, ADMIN_HTTP_ALLOWED,
			ADMIN_XMLRPC_ALLOWED, DEFAULT_TEMPLATESET, DEFAULT_MEMBERSHIP;
	public static final short MSG_ERROR = 4;
	public static final short LVL_MAJOR = 1;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public Vector<String> SERVER_NAME;
	public Properties props;
	public StringBuffer COOKIE_DOMAIN;
	public static final short MSG_CONFIG = 0;
	public static final short LVL_HALT = 0;
	public static final short MSG_TRAFFIC = 3;
	public static final short LVL_VERY_VERBOSE = 4;
	public InetAddress lh = null;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public Vector<InetAddress> allowedLoginHosts;
	public static final short LVL_VERBOSE = 3;
	public static final short MSG_STATE = 2;
	public static final short LVL_MINOR = 2;
	public static boolean TRACE_CREATE_AND_FINALIZE = false;
	public static Short LOG_MASK[] = new Short[7];
	public static boolean DEBUG = false;
	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };
	public static final short MSG_AUTH = 1;
	public static Calendar cal = Calendar.getInstance();
	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
