/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package freecs.util;

import freecs.Server;
import freecs.util.logger.LogWriter;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Hashtable;
import java.util.Enumeration;
import java.net.InetAddress;


public class TrafficMonitor extends Thread {
	public static final TrafficMonitor tm = new TrafficMonitor();

	private Hashtable<InetAddress, AddressState> addr;
	private long checkInterval = 10000;

	private TrafficMonitor () {
		addr = new Hashtable<InetAddress, AddressState> ();
	}

	/**
	 * Starts up the TrafficMonitor
	 */
	public static void startTrafficMonitor () {
		if (!USE_TRAFFIC_MONITOR)
			return;
		if (tm.isAlive())
            return;
        tm.setName("TrafficMonitor");
        tm.start ();
	}

	/**
	 * mayPass get's called for every new connection-atempt. If the configured
	 * maximum number of connection-atempts per host is reached, this method will
	 * return false. The Thread calling this method is responsible for baning this
	 * host. There is the possibility to destinguish between normal hosts and proxy-servers.
	 * Proxy-Servers will be allowed to connect more often than normal hosts.
	 * @param ia the inet-address of the host to count the connection-atempts
	 * @return true if this inet-adresses Host may pass, false if too many connection-atempts from this host where made
	 * @see freecs.Server
	 */
	public AddressState mayPass (InetAddress ia) {
		AddressState as = (AddressState) addr.get(ia);
		if (as == null) {
			addr.put (ia, new AddressState ());
			StringBuffer sb = new StringBuffer (" add InetAdress (");
			sb.append (ia.toString ());
			sb.append (")");
			log(this, sb.toString(), Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
			return null;
		}
		as.diff = System.currentTimeMillis () - as.lastCheck;
		if (as.diff > checkInterval) {
			as.reqCount = 1;
			as.lastCheck = System.currentTimeMillis ();
			return null;
		}
		as.reqCount++;
		if (as.isProxy) {
			if (as.reqCount > MAX_REQUESTS_PER_PROXY_IP) 
				return as;
		} else if (as.reqCount > MAX_REQUESTS_PER_IP) {
			       return as;
		}
		return null;
	}

	/**
	 * markAsProxy will mark this inet-adresses Host as proxy-server. This makes it
	 * possible to distiguish between normal- and proxy-hosts. Proxy-hosts well be
	 * allowed to make more connection-atempts than normal hosts.
	 * @param ia the inet-address which was identified as proxy-server
	 */
	public void markAsProxy (InetAddress ia) {
		if (!USE_TRAFFIC_MONITOR || srv.isAdminHost(ia)) 
			return;			
		AddressState as;
		as = (AddressState) addr.get(ia);
		if (as == null) {
			StringBuffer sb = new StringBuffer ("markAsProxy: AddressState is null(");
			sb.append (ia.toString ());
			sb.append (")");
			log(this, sb.toString(), Server.MSG_STATE, Server.LVL_MAJOR);
			return;
		}
		if (!as.isProxy) {
			StringBuffer sb = new StringBuffer ("TrafficMonitor.markAsProxy: identified a proxy (");
			sb.append (ia.toString ());
			sb.append (")");
			Server.log (this, sb.toString(), MSG_STATE, LVL_VERY_VERBOSE);
			as.isProxy = true;
		}
	}

	/**
	 * the run-method of this TrafficMonitor is responsible for cleaning up inet-addresses 
	 * which didn't connect to this Server for mor than 60000 millis.
	 */
	public void run () {
        long lastMessage=0;
		while (srv.isRunning ()) try {
            if (DEBUG || lastMessage + 5000 > System.currentTimeMillis()) {
                log(this, "loopstart", Server.MSG_STATE,
						Server.LVL_VERY_VERBOSE);
                lastMessage = System.currentTimeMillis();
            }
			long now = System.currentTimeMillis ();
			long lowestValue = 60000;
			for (Enumeration e = addr.keys (); e.hasMoreElements (); ) {
				InetAddress tia = (InetAddress) e.nextElement ();
				if (tia==null)
					continue;
				AddressState as = (AddressState) addr.get (tia);
				if (as==null)
					continue;
				long diff = now - as.lastCheck;
				if (diff > 60000) {
					addr.remove (tia);
				} else if (diff < lowestValue) {
					lowestValue=diff;
				}
			}
            if (lowestValue < 33)
                lowestValue = 33;
			try {
				Thread.sleep (lowestValue);
			} catch (InterruptedException ie) {}
		} catch (Exception e) {
			debug(this, "run:", e, Server.MSG_ERROR, Server.LVL_MAJOR);
		}
	}

	public class AddressState {
        volatile long lastCheck;
        public volatile long reqCount;
        public volatile long diff;
		volatile boolean isProxy = false;
		private AddressState () {
            lastCheck = System.currentTimeMillis ();
            reqCount = 1;
		}
	}
    
    public String toString() {
        return "[TrafficMonitor]";
    }

	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Debuging method configured by the loglevel mechanism
	 * @param prefix  to write before other stuff
	 * @param t  is the throwable to print the stacktrace from
	 * @param type  the type of message, konstants with MSG_ prefix are used here
	 * @param lvl  the level of atention to use here, konstants with LVL_ prefix are used here
	 */
	public static void debug(Object o, String prefix, Throwable t, short type,
			short lvl) {
		if (LOG_MASK[type].intValue() < lvl && !DEBUG)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(prefix);
		sb.append("\r\n");
		sb.append(t.toString());
		StackTraceElement ste[] = t.getStackTrace();
		for (int i = 0; i < ste.length; i++) {
			sb.append("\r\n    at ");
			sb.append(ste[i].getClassName());
			sb.append("(");
			sb.append(ste[i].getFileName());
			sb.append(":");
			sb.append(ste[i].getLineNumber());
			sb.append(")");
		}
		log(o, sb.toString(), type, lvl);
	}

	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static Server srv = null;

	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN,
			THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS,
			USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR,
			USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT,
			STRICT_HOST_BINDING, CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR,
			BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;

	public static final short MSG_STATE = 2;

	public static final short LVL_VERY_VERBOSE = 4;

	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;

	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS,
			MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION,
			DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION,
			READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL,
			MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER,
			MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE,
			MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP,
			MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE,
			MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH,
			ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC,
			TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER,
			JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR,
			MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;

	public static final short LVL_MAJOR = 1;

	public static boolean DEBUG = false;

	public static final short MSG_ERROR = 4;

	public static Short LOG_MASK[] = new Short[7];

	public static final short LVL_HALT = 0;

	public static final short MSG_CONFIG = 0;

	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };

	public static final short MSG_AUTH = 1;

	public static final short MSG_TRAFFIC = 3;

	public static Calendar cal = Calendar.getInstance();

	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
