/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Contributors:  Georg Lundesgaard

package org.apache.log4j.config;

import org.apache.log4j.Appender;
import org.apache.log4j.Level;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.ErrorHandler;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.InterruptedIOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Properties;

/**
   General purpose Object property setter. Clients repeatedly invokes
   {@link #setProperty setProperty(name,value)} in order to invoke setters
   on the Object specified in the constructor. This class relies on the
   JavaBeans {@link Introspector} to analyze the given Object Class using
   reflection.
   
   <p>Usage:
   <pre>
     PropertySetter ps = new PropertySetter(anObject);
     ps.set("name", "Joe");
     ps.set("age", "32");
     ps.set("isMale", "true");
   </pre>
   will cause the invocations anObject.setName("Joe"), anObject.setAge(32),
   and setMale(true) if such methods exist with those signatures.
   Otherwise an {@link IntrospectionException} are thrown.
  
   @author Anders Kristensen
   @since 1.1
 */
public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link #setProperty} one or more times.
    
    @param obj  the object for which to set properties
   */
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  
  /**
     Uses JavaBeans {@link Introspector} to computer setters of object to be
     configured.
   */
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error("Failed to introspect "+obj+": " + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  

  /**
     Set the properties of an object passed as a parameter in one
     go. The <code>properties</code> are parsed relative to a
     <code>prefix</code>.

     @param obj The object to configure.
     @param properties A java.util.Properties containing keys and values.
     @param prefix Only keys having the specified prefix will be set.
  */
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  

  /**
     Set the properites for the object that match the
     <code>prefix</code> passed as parameter.

     
   */
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      
      // handle only properties that start with the desired frefix.
      if (key.startsWith(prefix)) {

	
	// ignore key if it contains dots after the prefix
        if (key.indexOf('.', len + 1) > 0) {
	  //System.err.println("----------Ignoring---["+key
	  //	     +"], prefix=["+prefix+"].");
	  continue;
	}
        
	String value = findAndSubst(key, properties);
        key = key.substring(len);
        if (("layout".equals(key) || "errorhandler".equals(key)) && obj instanceof Appender) {
          continue;
        }
        //
        //   if the property type is an OptionHandler
        //     (for example, triggeringPolicy of org.apache.log4j.rolling.RollingFileAppender)
        PropertyDescriptor prop = getPropertyDescriptor(Introspector.decapitalize(key));
        if (prop != null
                && OptionHandler.class.isAssignableFrom(prop.getPropertyType())
                && prop.getWriteMethod() != null) {
            OptionHandler opt = (OptionHandler)
                    instantiateByKey(properties, prefix + key,
							prop.getPropertyType(), null);
            PropertySetter setter = new PropertySetter(opt);
            setter.setProperties(properties, prefix + key + ".");
            try {
                prop.getWriteMethod().invoke(this.obj, new Object[] { opt });
            } catch(IllegalAccessException ex) {
                LogLog.warn("Failed to set property [" + key +
                            "] to value \"" + value + "\". ", ex);
            } catch(InvocationTargetException ex) {
                if (ex.getTargetException() instanceof InterruptedException
                        || ex.getTargetException() instanceof InterruptedIOException) {
                    Thread.currentThread().interrupt();
                }
                LogLog.warn("Failed to set property [" + key +
                            "] to value \"" + value + "\". ", ex);
            } catch(RuntimeException ex) {
                LogLog.warn("Failed to set property [" + key +
                            "] to value \"" + value + "\". ", ex);
            }
            continue;
        }

        setProperty(key, value);
      }
    }
    activate();
  }
  
  /**
     Set a property on this PropertySetter's Object. If successful, this
     method will invoke a setter method on the underlying Object. The
     setter is the one for the specified property name and the value is
     determined partly from the setter argument type and partly from the
     value specified in the call to this method.
     
     <p>If the setter expects a String no conversion is necessary.
     If it expects an int, then an attempt is made to convert 'value'
     to an int using new Integer(value). If the setter expects a boolean,
     the conversion is by new Boolean(value).
     
     @param name    name of the property
     @param value   String value of the property
   */
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    
    //LogLog.debug("---------Key: "+name+", type="+prop.getPropertyType());

    if (prop == null) {
      LogLog.warn("No such property [" + name + "] in "+
		  obj.getClass().getName()+"." );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn("Failed to set property [" + name +
                    "] to value \"" + value + "\". ", ex.rootCause);
      }
    }
  }
  
  /** 
      Set the named property given a {@link PropertyDescriptor}.

      @param prop A PropertyDescriptor describing the characteristics
      of the property to set.
      @param name The named of the property to set.
      @param value The value of the property.      
   */
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException("No setter for property ["+name+"].");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException("#params for setter != 1");
    }
    
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException("Conversion to type ["+paramTypes[0]+
					"] failed. Reason: "+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          "Conversion to type ["+paramTypes[0]+"] failed.");
    }
    LogLog.debug("Setting property [" + name + "] to [" +arg+"].");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (IllegalAccessException ex) {
      throw new PropertySetterException(ex);
    } catch (InvocationTargetException ex) {
        if (ex.getTargetException() instanceof InterruptedException
                || ex.getTargetException() instanceof InterruptedIOException) {
            Thread.currentThread().interrupt();
        }        
        throw new PropertySetterException(ex);
    } catch (RuntimeException ex) {
      throw new PropertySetterException(ex);
    }
  }
  

  /**
     Convert <code>val</code> a String parameter to an object of a
     given type.
  */
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;

    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if ("true".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if ("false".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return toLevel(v, (Level) Level.DEBUG);
    } else if (ErrorHandler.class.isAssignableFrom(type)) {
      return instantiateByClassName(v, ErrorHandler.class, null);
    }
    return null;
  }
  
  
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }

/**
 * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.
 */
public static String findAndSubst(String key, Properties props) {
	String value = props.getProperty(key);
	if (value == null)
		return null;
	try {
		return substVars(value, props);
	} catch (IllegalArgumentException e) {
		LogLog.error("Bad option value [" + value + "].", e);
		return value;
	}
}

public static Object instantiateByKey(Properties props, String key,
		Class superClass, Object defaultValue) {
	String className = findAndSubst(key, props);
	if (className == null) {
		LogLog.error("Could not find value for key " + key);
		return defaultValue;
	}
	return OptionConverter.instantiateByClassName(className.trim(), superClass,
			defaultValue);
}

/**
 * Converts a standard or custom priority level to a Level object.  <p> If <code>value</code> is of form "level#classname", then the specified class' toLevel method is called to process the specified level string; if no '#' character is present, then the default  {@link org.apache.log4j.Level} class is used to process the level value. <p>As a special case, if the <code>value</code> parameter is equal to the string "NULL", then the value <code>null</code> will be returned. <p> If any error occurs while converting the value to a level, the <code>defaultValue</code> parameter, which may be <code>null</code>, is returned. <p> Case of <code>value</code> is insignificant for the level level, but is significant for the class name part, if present.
 * @since  1.1 
 */
public static Level toLevel(String value, Level defaultValue) {
	if (value == null)
		return defaultValue;
	value = value.trim();
	int hashIndex = value.indexOf('#');
	if (hashIndex == -1) {
		if ("NULL".equalsIgnoreCase(value)) {
			return null;
		} else {
			return (Level) Level.toLevel(value, defaultValue);
		}
	}
	Level result = defaultValue;
	String clazz = value.substring(hashIndex + 1);
	String levelName = value.substring(0, hashIndex);
	if ("NULL".equalsIgnoreCase(levelName)) {
		return null;
	}
	LogLog.debug("toLevel" + ":class=[" + clazz + "]" + ":pri=[" + levelName
			+ "]");
	try {
		Class customLevel = Loader.loadClass(clazz);
		Class[] paramTypes = new Class[] { String.class,
				org.apache.log4j.Level.class };
		java.lang.reflect.Method toLevelMethod = customLevel.getMethod(
				"toLevel", paramTypes);
		Object[] params = new Object[] { levelName, defaultValue };
		Object o = toLevelMethod.invoke(null, params);
		result = (Level) o;
	} catch (ClassNotFoundException e) {
		LogLog.warn("custom level class [" + clazz + "] not found.");
	} catch (NoSuchMethodException e) {
		LogLog.warn("custom level class [" + clazz + "]"
				+ " does not have a class function toLevel(String, Level)", e);
	} catch (java.lang.reflect.InvocationTargetException e) {
		if (e.getTargetException() instanceof InterruptedException
				|| e.getTargetException() instanceof InterruptedIOException) {
			Thread.currentThread().interrupt();
		}
		LogLog.warn("custom level class [" + clazz + "]"
				+ " could not be instantiated", e);
	} catch (ClassCastException e) {
		LogLog.warn("class [" + clazz
				+ "] is not a subclass of org.apache.log4j.Level", e);
	} catch (IllegalAccessException e) {
		LogLog.warn("class [" + clazz
				+ "] cannot be instantiated due to access restrictions", e);
	} catch (RuntimeException e) {
		LogLog.warn("class [" + clazz + "], level [" + levelName
				+ "] conversion failed.", e);
	}
	return result;
}

/**
 * Instantiate an object given a class name. Check that the <code>className</code> is a subclass of <code>superClass</code>. If that test fails or the object could not be instantiated, then <code>defaultValue</code> is returned.
 * @param className  The fully qualified class name of the object to instantiate.
 * @param superClass  The class to which the new object should belong.
 * @param defaultValue  The object to return in case of non-fulfillment
 */
public static Object instantiateByClassName(String className, Class superClass,
		Object defaultValue) {
	if (className != null) {
		try {
			Class classObj = Loader.loadClass(className);
			if (!superClass.isAssignableFrom(classObj)) {
				LogLog.error("A \"" + className
						+ "\" object is not assignable to a \""
						+ superClass.getName() + "\" variable.");
				LogLog.error("The class \"" + superClass.getName()
						+ "\" was loaded by ");
				LogLog.error("[" + superClass.getClassLoader()
						+ "] whereas object of type ");
				LogLog.error("\"" + classObj.getName() + "\" was loaded by ["
						+ classObj.getClassLoader() + "].");
				return defaultValue;
			}
			return classObj.newInstance();
		} catch (ClassNotFoundException e) {
			LogLog.error("Could not instantiate class [" + className + "].", e);
		} catch (IllegalAccessException e) {
			LogLog.error("Could not instantiate class [" + className + "].", e);
		} catch (InstantiationException e) {
			LogLog.error("Could not instantiate class [" + className + "].", e);
		} catch (RuntimeException e) {
			LogLog.error("Could not instantiate class [" + className + "].", e);
		}
	}
	return defaultValue;
}

/**
 * Perform variable substitution in string <code>val</code> from the values of keys found in the system propeties. <p>The variable substitution delimeters are <b>${</b> and <b>}</b>. <p>For example, if the System properties contains "key=value", then the call <pre> String s = OptionConverter.substituteVars("Value of key is ${key}."); </pre> will set the variable <code>s</code> to "Value of key is value.". <p>If no value could be found for the specified key, then the <code>props</code> parameter is searched, if the value could not be found there, then substitution defaults to the empty string. <p>For example, if system propeties contains no value for the key "inexistentKey", then the call <pre> String s = OptionConverter.subsVars("Value of inexistentKey is [${inexistentKey}]"); </pre> will set <code>s</code> to "Value of inexistentKey is []" <p>An  {@link java.lang.IllegalArgumentException}  is thrown if <code>val</code> contains a start delimeter "${" which is not balanced by a stop delimeter "}". </p> <p><b>Author</b> Avy Sharell</a></p>
 * @param val  The string on which variable substitution is performed.
 * @throws IllegalArgumentException  if <code>val</code> is malformed.
 */
public static String substVars(String val, Properties props)
		throws IllegalArgumentException {
	StringBuffer sbuf = new StringBuffer();
	int i = 0;
	int j, k;
	while (true) {
		j = val.indexOf(DELIM_START, i);
		if (j == -1) {
			if (i == 0) {
				return val;
			} else {
				sbuf.append(val.substring(i, val.length()));
				return sbuf.toString();
			}
		} else {
			sbuf.append(val.substring(i, j));
			k = val.indexOf(DELIM_STOP, j);
			if (k == -1) {
				throw new IllegalArgumentException('"' + val
						+ "\" has no closing brace. Opening brace at position "
						+ j + '.');
			} else {
				j += DELIM_START_LEN;
				String key = val.substring(j, k);
				String replacement = getSystemProperty(key, null);
				if (replacement == null && props != null) {
					replacement = props.getProperty(key);
				}
				if (replacement != null) {
					String recursiveReplacement = substVars(replacement, props);
					sbuf.append(recursiveReplacement);
				}
				i = k + DELIM_STOP_LEN;
			}
		}
	}
}

/**
 * Very similar to <code>System.getProperty</code> except that the  {@link SecurityException}  is hidden.
 * @param key  The key to search for.
 * @param def  The default value to return.
 * @return  the string value of the system property, or the default value if there is no property with that key.
 * @since  1.1 
 */
public static String getSystemProperty(String key, String def) {
	try {
		return System.getProperty(key, def);
	} catch (Throwable e) {
		LogLog.debug("Was not allowed to read system property \"" + key + "\".");
		return def;
	}
}

static String DELIM_START = "${";
static char DELIM_STOP = '}';
static int DELIM_START_LEN = 2;
static int DELIM_STOP_LEN = 1;
}

//*********************REFACTORED CODE ****************
