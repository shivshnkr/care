//
// Informa -- RSS Library for Java
// Copyright (c) 2002 by Niko Schmuck
//
// Niko Schmuck
// http://sourceforge.net/projects/informa
// mailto:niko_schmuck@users.sourceforge.net
//
// This library is free software.
//
// You may redistribute it and/or modify it under the terms of the GNU
// Lesser General Public License as published by the Free Software Foundation.
//
// Version 2.1 of the license should be included with this distribution in
// the file LICENSE. If the license is not included with this distribution,
// you may find a copy at the FSF web site at 'www.gnu.org' or 'www.fsf.org',
// or you may write to the Free Software Foundation, 675 Mass Ave, Cambridge,
// MA 02139 USA.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied waranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//


// $Id: Item.java,v 1.34 2006/12/04 23:42:31 italobb Exp $

package de.nava.informa.impl.basic;

import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import org.jdom.Element;
import org.jdom.Namespace;

import de.nava.informa.core.CategoryIF;
import de.nava.informa.core.ChannelIF;
import de.nava.informa.core.ItemEnclosureIF;
import de.nava.informa.core.ItemGuidIF;
import de.nava.informa.core.ItemIF;
import de.nava.informa.core.ItemSourceIF;
import de.nava.informa.utils.XmlPathUtils;

/**
 * In-Memory implementation of the ItemIF interface.
 *
 * @author Niko Schmuck (niko@nava.de)
 */
public class Item implements ItemIF {

	private static final long serialVersionUID = -8346101720187629760L;

	private long id;
  private String title;
  private String description;
  private URL link;
  private Collection<CategoryIF> categories;
  private String creator;
  private String subject;
  private Date date;
  private Date found;
  private ItemGuidIF guid;
  private URL comments;
  private ItemSourceIF source;
  private ItemEnclosureIF enclosure;
  private Element itemElement;
  private ChannelIF channel;
  private boolean unRead;

  public Item() {
    this(null, null, "[Unknown Item]", null, null);
  }

  public Item(String title, String description, URL link) {
    this(null, null, title, description, link);
  }

  public Item(ChannelIF channel, String title, String description, URL link) {
    this(null, channel, title, description, link);
  }

  public Item(Element itemElement, String title, String description, URL link) {
    this(itemElement, null, title, description, link);
  }

  public Item(Element itemElement, ChannelIF channel, String title, String description, URL link) {
    this.id = IdGenerator.getInstance().getId();
    this.itemElement = itemElement;
    this.channel = channel;
    this.title = title;
    this.description = description;
    this.link = link;
    this.categories = new ArrayList<CategoryIF>();
    this.unRead = true;
    unRead = true;
  }

  // --------------------------------------------------------------
  // implementation of ItemIF interface
  // --------------------------------------------------------------

  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  public ChannelIF getChannel() {
    return channel;
  }

  public void setChannel(ChannelIF channel) {
    this.channel = channel;
  }

  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }

  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public boolean getUnRead() {
    return unRead;
  }

  public void setUnRead(boolean val) {
    unRead = val;
  }

  public URL getLink() {
    return link;
  }

  public void setLink(URL link) {
    this.link = link;
  }

  public Collection getCategories() {
    return categories;
  }

  public void setCategories(Collection<CategoryIF> categories) {
    this.categories = categories;
  }

  public void addCategory(CategoryIF category) {
    categories.add(category);
  }

  public void removeCategory(CategoryIF category) {
    categories.remove(category);
  }

  public String getCreator() {
    return creator;
  }

  public void setCreator(String creator) {
    this.creator = creator;
  }

  public String getSubject() {
    return subject;
  }

  public void setSubject(String subject) {
    this.subject = subject;
  }

  public Date getDate() {
    return date;
  }

  public void setDate(Date date) {
    this.date = date;
  }

  public Date getFound() {
    return found;
  }

  public void setFound(Date found) {
    this.found = found;
  }

  public ItemGuidIF getGuid() {
    return guid;
  }

  public void setGuid(ItemGuidIF guid) {
    this.guid = guid;
  }

  public URL getComments() {
    return comments;
  }

  public void setComments(URL comments) {
    this.comments = comments;
  }

  public ItemSourceIF getSource() {
    return source;
  }

  public void setSource(ItemSourceIF source) {
    this.source = source;
  }

  public ItemEnclosureIF getEnclosure() {
    return enclosure;
  }

  public void setEnclosure(ItemEnclosureIF enclosure) {
    this.enclosure = enclosure;
  }

  public String getElementValue(final String path) {
    return getElementValue(itemElement, path);
  }

  public String[] getElementValues(final String path, final String[] elements) {
    return getElementValues(itemElement, path, elements);
  }

  public String getAttributeValue(final String path, final String attribute) {
    return getAttributeValue(itemElement, path, attribute);
  }

  public String[] getAttributeValues(final String path, final String[] attributes) {
    return getAttributeValues(itemElement, path, attributes);
  }

  // ----------------------------------------------------------------------
  // overwrite default method implementation from Object
  // ----------------------------------------------------------------------

  /**
   * Indicates whether some other object is "equal to" this one.
   *
   * @param   o the reference object with which to compare.
   *
   * @return  <code>true</code> if this object is the same as the obj
   *          argument; <code>false</code> otherwise.
   *
   * NOTE: Please keep this code in sync with de.nava.informa.impl.hibernate.Item.equals().
   *
   * @see     #hashCode()
   */
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof ItemIF)) return false;

    final ItemIF item = (ItemIF) o;

    final String itemTitle = item.getTitle();
    if (title != null
      ? !title.equals(itemTitle)
      : itemTitle != null) return false;

    // Comparison of links uses synchronized code of Java-NET.
    // This may hurt multi-threaded applications. So, please think twice
    // before using direct comparison of links.
    final URL itemLink = item.getLink();
    if (link != null
      ? itemLink == null || !link.toString().equalsIgnoreCase(itemLink.toString())
      : itemLink != null) return false;

    final String itemDescription = item.getDescription();
    if (description != null
      ? !description.equals(itemDescription)
      : itemDescription != null) return false;

    return true;
  }

  /**
   * Returns a hash code value for the object. This method is
   * supported for the benefit of hashtables such as those provided by
   * <code>java.util.Hashtable</code>.
   *
   * NOTE: Please keep this code in sync with de.nava.informa.impl.hibernate.Item.hashCode().
   *
   * @return a hash code value for this object.
   */
  public int hashCode() {
    StringBuffer sb = new StringBuffer(64);
    sb.append(title).append(description).append(link);
    return sb.toString().hashCode();
  }

  /**
   * Returns a string representation of the object.
   *
   * @return  a string representation of the object.
   */
  public String toString() {
    return "[Item (" + id + "): " + title + "]";
  }

/**
 * Returns the value of  an element's child element reached by the given path. Traverses the DOM tree from the parent until the child is reached.
 * @param parent  the parent <code>Element</code>
 * @param childPath  a path to the root of the elements. Paths are specified as element names, separated by a "/". Namespaces are allowed. e.g. "aaa:bbb/ccc:ddd/eee".
 * @return  the value of the child. <br>If <code>parent</code> is <code>null</code>, returns <code>null</code>. If <code>childPath</code> is null, returns the value of the parent.
 */
public static String getElementValue(final Element parent,
		final String childPath) {
	if (parent == null) {
		return null;
	} else {
		Element child = getLeafChild(parent, childPath);
		return (child == null) ? null : child.getTextTrim();
	}
}

/**
 * Returns the values of the specified sub-elements of the child element reached by the given path. This is useful in cases where a child has several children. Traverses the DOM tree from the parent until the root is reached, then reads the specified elements.
 * @param parent  the parent <code>Element</code>
 * @param childPath  a path to the root of the elements. Paths are specified as element names, separated by a "/". Namespaces are allowed. e.g. "aaa:bbb/ccc:ddd/eee".
 * @param elements  An array of element names. May contain namespace specifiers.
 * @return  an array containing the value of each element. <br>If <code>parent</code> or <code>elements</code> is <code>null</code>, returns <code>null</code>. If <code>childPath</code> is null, returns the specified sub-elements of the parent.
 */
public static String[] getElementValues(final Element parent,
		final String childPath, final String[] elements) {
	if (parent == null) {
		return null;
	} else {
		Element child = getLeafChild(parent, childPath);
		return getElementValues(child, elements);
	}
}

/**
 * Returns the value of the attribute of the child element reached by the given path. Traverses the DOM tree from the parent until the child is reached, then reads the given attribute.
 * @param parent  the parent <code>Element</code>
 * @param childPath  a path to the root of the elements. Paths are specified as element names, separated by a "/".
 * @param attribute  the attribute. May contain a namespace specifier e.g. "rdf:resource".
 * @return  the value of the attribute. <br>If <code>parent</code> or <code>attribute</code> is <code>null</code>, returns <code>null</code> . If <code>childPath</code> is null, returns the specified attribute of the parent.
 */
public static String getAttributeValue(final Element parent,
		final String childPath, final String attribute) {
	if ((parent == null) || (attribute == null)) {
		return null;
	} else {
		Element child = getLeafChild(parent, childPath);
		return getAttributeValue(child, attribute);
	}
}

/**
 * Returns the value of the child element reached by the given path. This is useful in cases where a child has several attributes. Traverses the DOM tree from the parent until the child is reached.
 * @param parent  the parent <code>Element</code>
 * @param childPath  a path to the root of the elements. Paths are specified as element names, separated by a "/". Namespaces are allowed. e.g. "aaa:bbb/ccc:ddd/eee".
 * @param attributes  - An array of element names. May contain namespace specifiers.
 * @return  the value of the child. <br>If <code>parent</code> or <code>attributes</code> is <code>null</code>, returns <code>null</code>. If <code>childPath</code> is null, returns the specified attributes of the parent.
 */
public static String[] getAttributeValues(final Element parent,
		final String childPath, final String[] attributes) {
	if ((parent == null) || (attributes == null)) {
		return null;
	} else {
		Element child = getLeafChild(parent, childPath);
		return getAttributeValues(child, attributes);
	}
}

/**
 * Returns an <code>Element's</code> child corresponding to the given path. Traverses the DOM tree from the parent until the child is reached.
 * @param parent  the parent <code>Element</code>
 * @param childPath  a path to the root of the elements. Paths are specified as element names, separated by a "/".
 * @return  the child. <br>If <code>childPath</code> is null, return <code>parent</code>.
 */
private static Element getLeafChild(final Element parent, final String childPath) {
	if (childPath == null)
		return parent;
	List elementNames = getElementNames(childPath);
	Iterator iterator = elementNames.iterator();
	Element nextChild = parent;
	while (iterator.hasNext() && (nextChild != null)) {
		String elementName = (String) iterator.next();
		nextChild = getChild(nextChild, elementName);
	}
	return nextChild;
}

/**
 * Converts a path into a <code>List</code> of element names.
 * @param childPath  a path. e.g. "aaa:bbb/ccc:ddd/eee"
 * @return  a <code>List</code> of element names. e.g. "aaa:bbb", "ccc:ddd", "eee".
 */
private static List getElementNames(final String childPath) {
	List<String> strArray = new ArrayList<String>();
	if (childPath != null) {
		StringTokenizer st = new StringTokenizer(childPath, elementDelim);
		while (st.hasMoreTokens()) {
			String token = st.nextToken();
			if (token.length() > 0) {
				strArray.add(token);
			}
		}
	}
	return strArray;
}

/**
 * Returns an <code>Element's</code> child corresponding to the given child name.
 * @param parent  the parent <code>Element</code>
 * @param childName  the child's name. May contain a namespace specifier.
 * @return  the child.
 */
private static Element getChild(final Element parent, final String childName) {
	int prefixPos = childName.indexOf(prefixDelim);
	if ((prefixPos == 0) || (prefixPos >= childName.length() - 1)) {
		return null;
	} else {
		if (prefixPos == -1) {
			return parent.getChild(childName, getNamespace(parent, null));
		} else {
			String prefix = childName.substring(0, prefixPos);
			String childElementName = childName.substring(prefixPos + 1);
			return parent.getChild(childElementName,
					getNamespace(parent, prefix));
		}
	}
}

/**
 * Returns the Namespace corresponding to an element and a prefix.
 * @param element  the element.
 * @param prefix  the prefix.
 * @return  the Namespace.
 */
private static Namespace getNamespace(final Element element, final String prefix) {
	Namespace namespace = (prefix == null) ? element.getNamespace("") : element
			.getNamespace(prefix);
	return (namespace == null) ? Namespace.NO_NAMESPACE : namespace;
}

private static final String elementDelim = "/";

private static final String prefixDelim = ":";

}

//*********************REFACTORED CODE ****************
