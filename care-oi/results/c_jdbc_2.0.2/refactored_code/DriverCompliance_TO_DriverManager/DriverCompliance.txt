/**
 * C-JDBC: Clustered JDBC.
 * Copyright (C) 2002-2004 French National Institute For Research In Computer
 * Science And Control (INRIA).
 * Contact: c-jdbc@objectweb.org
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or any later
 * version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 *
 * Initial developer(s): Emmanuel Cecchet. 
 * Contributor(s): ______________________.
 */

package org.objectweb.cjdbc.controller.backend;

import java.io.File;
import java.io.IOException;
import java.net.ConnectException;
import java.net.URL;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Driver;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.objectweb.cjdbc.common.i18n.Translate;
import org.objectweb.cjdbc.common.log.Trace;
import org.objectweb.cjdbc.controller.connection.DriverClassLoader;
import org.objectweb.cjdbc.controller.connection.DriverManager;
import org.objectweb.cjdbc.controller.core.Controller;
import org.objectweb.cjdbc.controller.core.ControllerConstants;

/**
 * This class checks if a given driver provides the mandatory features necessary
 * for C-JDBC.
 * 
 * @author <a href="mailto:Emmanuel.Cecchet@inria.fr">Emmanuel Cecchet </a>
 * @version 1.0
 */
public class DriverCompliance
{
  private boolean             isCompliant                 = false;
  private boolean             hasBeenTested               = false;
  private boolean             supportSetQueryTimeout      = false;
  private boolean             supportGetGeneratedKeys     = false;
  private boolean             supportGetColumnCount       = false;
  private boolean             supportGetColumnClassName   = false;
  private boolean             supportGetColumnTypeName    = false;
  private boolean             supportGetColumnType        = false;
  private boolean             supportGetColumnDisplaySize = false;
  private boolean             supportGetTableName         = false;
  private boolean             supportSetCursorName        = false;
  private boolean             supportSetFetchSize         = false;
  private boolean             supportSetMaxRows           = false;

  private Trace               logger;

  private static final int    TIMEOUT_VALUE               = 1000;
  private static final String DEFAULT_TEST_STATEMENT      = "select 1";
  private String              databaseProductName         = "C-JDBC";

  /**
   * Builds a new DriverCompliance object.
   * 
   * @param logger the logger to use
   */
  public DriverCompliance(Trace logger)
  {
    this.logger = logger;
  }

  /**
   * Check the driver compliance.
   * 
   * @param backendUrl the JDBC URL to connect to
   * @param login the user login
   * @param password the user password
   * @param driverPath path for driver
   * @param driverClassName class name for driver
   * @param connectionTestStatement SQL statement used to check if a connection
   *          is still valid
   * @return true if the driver is C-JDBC compliant
   * @throws ConnectException if it is not possible to connect to the backend
   */
  public boolean complianceTest(String backendUrl, String login,
      String password, String driverPath, String driverClassName,
      String connectionTestStatement) throws ConnectException
  {
    if (hasBeenTested)
      return isCompliant;

    isCompliant = false;

    Connection c = null;
    try
    {
      c = getConnection(backendUrl, login, password, driverPath, driverClassName);
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.test.connection.failed", e),
            e);
      else
        logger.error(Translate.get("backend.driver.test.connection.failed", e));
      throw new ConnectException(e.getMessage());
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.test.connection.ok"));

    DatabaseMetaData connectionMetaData;
    try
    {
      connectionMetaData = c.getMetaData();
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger
            .debug(Translate.get("backend.driver.test.metadata.failed", e), e);
      else
        logger.error(Translate.get("backend.driver.test.metadata.failed", e));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.test.metadata.ok"));

    try
    {
      this.databaseProductName = connectionMetaData.getDatabaseProductName();
      logger.info(Translate
          .get("backend.detected.as", this.databaseProductName));
    }
    catch (Exception e)
    {
      logger.warn(Translate
          .get("backend.driver.test.database.productname.failed"));
    }

    Statement s;
    try
    {
      s = c.createStatement();
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.test.statement.failed", e),
            e);
      else
        logger.error(Translate.get("backend.driver.test.statement.failed", e));
      return isCompliant;
    }

    try
    {
      if (connectionTestStatement == null)
      {
        if (logger.isDebugEnabled())
          logger.debug(Translate.get("backend.driver.using.default.statement",
              DEFAULT_TEST_STATEMENT));
        connectionTestStatement = DEFAULT_TEST_STATEMENT;
      }
      s.execute(connectionTestStatement);
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.test.statement.invalid",
            new String[]{connectionTestStatement, e.getMessage()}), e);
      else
        logger.error(Translate.get("backend.driver.test.statement.invalid",
            new String[]{connectionTestStatement, e.getMessage()}));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.test.statement.ok"));

    try
    {
      s.setCursorName("testcursor");
      supportSetCursorName = true;
      if (logger.isDebugEnabled())
        logger
            .debug(Translate.get("backend.driver.statement.setCursorName.ok"));
    }
    catch (Exception e1)
    {
      logger.warn(Translate
          .get("backend.driver.statement.setCursorName.failed"));
      supportSetMaxRows = false;
    }

    try
    {
      s.setFetchSize(25);
      supportSetFetchSize = true;
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.statement.setFetchSize.ok"));
    }
    catch (Exception e1)
    {
      logger
          .warn(Translate.get("backend.driver.statement.setFetchSize.failed"));
      supportSetMaxRows = false;
    }

    try
    {
      s.setMaxRows(5);
      supportSetMaxRows = true;
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.statement.setMaxRows.ok"));
    }
    catch (Exception e1)
    {
      logger.warn(Translate.get("backend.driver.statement.setMaxRows.failed"));
      supportSetMaxRows = false;
    }

    try
    {
      s.getGeneratedKeys();
      supportGetGeneratedKeys = true;
      if (logger.isDebugEnabled())
        logger.debug(Translate
            .get("backend.driver.statement.getGeneratedKeys.ok"));
    }
    catch (Exception e1)
    {
      logger.warn(Translate
          .get("backend.driver.statement.getGeneratedKeys.failed"));
      supportGetGeneratedKeys = false;
    }
    catch (AbstractMethodError e1)
    {
      logger.warn(Translate
          .get("backend.driver.statement.getGeneratedKeys.failed"));
      supportGetGeneratedKeys = false;
    }
    catch (java.lang.NoSuchMethodError e1)
    {
      logger.warn(Translate
          .get("backend.driver.statement.getGeneratedKeys.failed"));
      supportGetGeneratedKeys = false;
    }

    // Commented out:
    // A prepared statement can be sent to the DBMS right away to be compiled
    // Should fine a work around for this test.

    // PreparedStatement ps;
    // try
    // {
    // ps = c.prepareStatement("INSERT INTO versions VALUES (?,?)");
    // ps.setInt(1, 10);
    // ps.setString(2, "just a test");
    // }
    // catch (Exception e)
    // {
    // logger.warn(Translate.get("backend.driver.prepared.statement.failed"),
    // e);
    // }
    // if (logger.isDebugEnabled())
    // logger.debug(Translate.get("backend.driver.prepared.statement.ok"));

    try
    {
      s.setQueryTimeout(TIMEOUT_VALUE);
      supportSetQueryTimeout = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get("backend.driver.setQueryTimeout.failed", e));
    }
    if (supportSetQueryTimeout && logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.setQueryTimeout.ok"));

    ResultSet rs;
    try
    {
      String[] types = {"TABLE", "VIEW"};
      rs = connectionMetaData.getTables(null, null, "%", types);
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.metadata.getTables.failed",
            e), e);
      else
        logger.error(Translate.get("backend.driver.metadata.getTables.failed",
            e));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.metadata.getTables.ok"));

    java.sql.ResultSetMetaData rsMetaData;
    try
    {
      rsMetaData = rs.getMetaData();
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get(
            "backend.driver.resultset.getMetaData.failed", e), e);
      else
        logger.error(Translate.get(
            "backend.driver.resultset.getMetaData.failed", e));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.resultset.getMetaData.ok"));

    try
    {
      if (rs.next() && (rsMetaData.getColumnCount() > 0))
      {
        rs.getObject(1);
      }
      else
        logger.warn(Translate.get("backend.driver.resultset.getObject.unable"));
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get("backend.driver.resultset.getObject.failed",
            e), e);
      else
        logger.error(Translate.get("backend.driver.resultset.getObject.failed",
            e));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.resultset.getObject.ok"));

    try
    {
      rsMetaData.getColumnCount();
      supportGetColumnCount = true;
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get(
            "backend.driver.metadata.getColumnCount.failed", e), e);
      else
        logger.error(Translate.get(
            "backend.driver.metadata.getColumnCount.failed", e));
      return isCompliant;
    }
    if (supportGetColumnCount && logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.metadata.getColumnCount.ok"));

    try
    {
      rsMetaData.getColumnName(1);
    }
    catch (Exception e)
    {
      if (logger.isDebugEnabled())
        logger.debug(Translate.get(
            "backend.driver.metadata.getColumnName.failed", e), e);
      else
        logger.error(Translate.get(
            "backend.driver.metadata.getColumnName.failed", e));
      return isCompliant;
    }
    if (logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.metadata.getColumnName.ok"));

    try
    {
      rsMetaData.getTableName(1);
      supportGetTableName = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get("backend.driver.metadata.getTableName.failed",
          e));
    }

    if (supportGetTableName && logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.metadata.getTableName.ok"));

    try
    {
      rsMetaData.getColumnDisplaySize(1);
      supportGetColumnDisplaySize = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get(
          "backend.driver.metadata.getColumnDisplaySize.failed", e));
    }
    if (supportGetColumnDisplaySize && logger.isDebugEnabled())
      logger.debug(Translate
          .get("backend.driver.metadata.getColumnDisplaySize.ok"));

    try
    {
      rsMetaData.getColumnType(1);
      supportGetColumnType = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get("backend.driver.metadata.getColumnType.failed",
          e));
    }
    if (supportGetColumnType && logger.isDebugEnabled())
      logger.debug(Translate.get("backend.driver.metadata.getColumnType.ok"));

    try
    {
      rsMetaData.getColumnTypeName(1);
      supportGetColumnTypeName = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get(
          "backend.driver.metadata.getColumnTypeName.failed", e));
    }
    if (supportGetColumnTypeName && logger.isDebugEnabled())
      logger.debug(Translate
          .get("backend.driver.metadata.getColumnTypeName.ok"));

    try
    {
      rsMetaData.getColumnClassName(1);
      supportGetColumnClassName = true;
    }
    catch (Exception e)
    {
      logger.warn(Translate.get(
          "backend.driver.metadata.getColumnClassName.failed", e));
    }
    if (supportGetColumnClassName && logger.isDebugEnabled())
      logger.debug(Translate
          .get("backend.driver.metadata.getColumnClassName.ok"));

    isCompliant = true;
    hasBeenTested = true;
    return isCompliant;
  }

  /**
   * @return true if the driver is compliant to the C-JDBC requirements
   */
  public boolean isCompliant()
  {
    return isCompliant;
  }

  /**
   * @return true if the driver supports getGeneratedKeys
   */
  public boolean supportGetGeneratedKeys()
  {
    return supportGetGeneratedKeys;
  }

  /**
   * @return true if the driver supports getColumnClassName
   */
  public boolean supportGetColumnClassName()
  {
    return supportGetColumnClassName;
  }

  /**
   * @return true if the driver supports getColumnCount
   */
  public boolean supportGetColumnCount()
  {
    return supportGetColumnCount;
  }

  /**
   * @return true if the driver supports getColumnDisplaySize
   */
  public boolean supportGetColumnDisplaySize()
  {
    return supportGetColumnDisplaySize;
  }

  /**
   * @return true if the driver supports getColumnType
   */
  public boolean supportGetColumnType()
  {
    return supportGetColumnType;
  }

  /**
   * @return true if the driver supports getColumnTypeName
   */
  public boolean supportGetColumnTypeName()
  {
    return supportGetColumnTypeName;
  }

  /**
   * @return true if the driver supports getTableName
   */
  public boolean supportGetTableName()
  {
    return supportGetTableName;
  }

  /**
   * @return true if the driver supports setQueryTimeout
   */
  public boolean supportSetQueryTimeout()
  {
    return supportSetQueryTimeout;
  }

  /**
   * @return true if the driver supports Statement.setMaxRows
   */
  public boolean supportSetMaxRows()
  {
    return supportSetMaxRows;
  }

  /**
   * Returns the supportSetCursorName value.
   * 
   * @return Returns the supportSetCursorName.
   */
  public boolean supportSetCursorName()
  {
    return supportSetCursorName;
  }

  /**
   * Returns the supportSetFetchSize value.
   * 
   * @return Returns the supportSetFetchSize.
   */
  public boolean supportSetFetchSize()
  {
    return supportSetFetchSize;
  }

  /**
   * Returns the databaseProductName value.
   * 
   * @return Returns the databaseProductName.
   */
  public String getDatabaseProductName()
  {
    return this.databaseProductName;
  }

/**
 * Attempts to establish a connection to the given database URL. The <code>DriverManager</code> attempts to select an appropriate driver from the set of registered JDBC drivers.
 * @param url  a database url of the form <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>
 * @param user  the database user on whose behalf the connection is being made
 * @param password  the user's password
 * @param driverPathName  the path where the driver classes are located, null if default directory
 * @param driverClassName  the class name of the driver
 * @return  a connection to the URL
 * @exception SQLException  if a database access error occurs
 */
public static Connection getConnection(String url, String user,
		String password, String driverPathName, String driverClassName)
		throws SQLException {
	Driver driver = null;
	boolean isDefaultPath = false;
	if (driverPathName == null) {
		driver = (Driver) namedDrivers.get(driverClassName);
		if (driver == null) {
			try {
				if (driverClassName != null) {
					loadDriverClass(driverClassName);
				}
				return java.sql.DriverManager
						.getConnection(url, user, password);
			} catch (ClassNotFoundException e) {
				if (driverClassName == null) {
					throw new SQLException(
							"could not load driver as no class name is specified ");
				}
				try {
					driverPathName = getDriversDir().getAbsolutePath();
					isDefaultPath = true;
				} catch (IOException ioExc) {
					throw new SQLException(
							"could not find default drivers directory");
				}
			}
		}
	}
	if (driver == null) {
		driver = (Driver) namedDrivers.get(driverPathName);
	}
	if (driver == null) {
		try {
			File path = convertToAbsolutePath(driverPathName);
			if (logger.isDebugEnabled()) {
				logger.debug("loading driver with name " + driverPathName
						+ " for class " + driverClassName);
			}
			driver = loadDriver(path, driverClassName);
		} catch (Exception e) {
			logger.error("Could not load driver for class " + driverClassName,
					e);
			throw new SQLException("could not load driver for class name "
					+ driverClassName + " and driverPath " + driverPathName);
		}
		if (isDefaultPath) {
			namedDrivers.put(driverClassName, driver);
		} else {
			namedDrivers.put(driverPathName, driver);
		}
	}
	return getConnectionForDriver(url, user, password, driver);
}

/**
 * Load the driver class
 * @param driverClassName  the class name of the driver
 * @throws ClassNotFoundException  if the class could not be found
 */
public static void loadDriverClass(String driverClassName)
		throws ClassNotFoundException {
	if (!defaultDrivers.contains(driverClassName)) {
		if (logger.isDebugEnabled()) {
			logger.debug("we are using default classloader and driverClassName ="
					+ driverClassName);
		}
		Class.forName(driverClassName);
		if (logger.isDebugEnabled())
			logger.debug(Translate
					.get("backend.driver.loaded", driverClassName));
		defaultDrivers.add(driverClassName);
	}
}

private static File getDriversDir() throws IOException {
	URL url = Controller.class
			.getResource(ControllerConstants.C_JDBC_DRIVER_JAR_FILE);
	if (url == null) {
		String msg = Translate.get("controller.driver.dir.not.found");
		logger.error(msg);
		throw new IOException(msg);
	}
	File driversDir = new File(url.getFile()).getParentFile();
	if (!driversDir.exists()) {
		String msg = Translate.get("controller.driver.dir.not.found");
		logger.error(msg);
		throw new IOException(msg);
	}
	return driversDir;
}

/**
 * convert a path into an absolute path if the path is already an absolute path, it is just returned otherwise a relative path is considered to be relative to the drivers directory
 * @param pathName  the relativ or absolute path
 * @return  the converted path
 * @throws IOException  if the converted path does not exist
 */
public static File convertToAbsolutePath(String pathName) throws IOException {
	File dir = null;
	if (pathName != null) {
		File path = new File(pathName);
		if (path.canRead())
			return path;
		else
			throw new IOException("Invalid path name " + pathName);
	} else {
		dir = getDriversDir();
	}
	if (!dir.canRead()) {
		String msg = Translate.get("controller.driver.dir.not.found");
		logger.error(msg);
		throw new IOException(msg);
	}
	return dir;
}

private static Driver loadDriver(File path, String driverClassName)
		throws ClassNotFoundException, InstantiationException,
		IllegalAccessException {
	ClassLoader loader = new DriverClassLoader(null, path);
	Class.forName(java.sql.DriverManager.class.getName(), true, loader);
	Class driverClass = Class.forName(driverClassName, true, loader);
	if (logger.isDebugEnabled())
		logger.debug(Translate.get("backend.driver.loaded", driverClassName));
	return (Driver) driverClass.newInstance();
}

private static Connection getConnectionForDriver(String url, String user,
		String password, Driver driver) throws SQLException {
	java.util.Properties info = new java.util.Properties();
	if (user != null) {
		info.put("user", user);
	}
	if (password != null) {
		info.put("password", password);
	}
	return driver.connect(url, info);
}

/**
 * We keep a reference to already loaded named drivers. Each named driver has been loaded with a separate classloader.
 */
private static Map namedDrivers = new HashMap();
/**
 * Logger instance. 
 */
static Trace logger = Trace
		.getLogger("org.objectweb.cjdbc.controller.connection.DriverManager");
/**
 * Driver class names read from default drivers, without driverPath
 */
private static Set defaultDrivers = new HashSet();
}
//*********************REFACTORED CODE ****************
