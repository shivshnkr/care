/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package org.apache.batik.ext.awt.image.rendered;


import org.apache.batik.ext.awt.image.GraphicsUtil;

import java.awt.Rectangle;

import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferInt;
import java.awt.image.Raster;
import java.awt.image.SampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;
/**
 * This implements CachableRed based on a BufferedImage.
 * You can use this to wrap a BufferedImage that you want to
 * appear as a CachableRed.
 * It essentially ignores the dependency and dirty region methods.
 *
 * @author <a href="mailto:Thomas.DeWeeese@Kodak.com">Thomas DeWeese</a>
 * @version $Id: BufferedImageCachableRed.java,v 1.1 2003/04/11 07:56:53 tom Exp $ */
public class BufferedImageCachableRed extends AbstractRed {
    // The bufferedImage that we wrap...
    BufferedImage bi;

    /**
     * Construct an instance of CachableRed around a BufferedImage.
     */
    public BufferedImageCachableRed(BufferedImage bi) {
        super((CachableRed)null, 
              new Rectangle(bi.getMinX(),  bi.getMinY(),
                            bi.getWidth(), bi.getHeight()),
              bi.getColorModel(), bi.getSampleModel(), 
              bi.getMinX(), bi.getMinY(), null);

        this.bi = bi;
    }

    public BufferedImageCachableRed(BufferedImage bi, 
                                            int xloc, int yloc) {
        super((CachableRed)null, new Rectangle(xloc,  yloc,
                                               bi.getWidth(), 
                                               bi.getHeight()),
              bi.getColorModel(), bi.getSampleModel(), xloc, yloc, null);

        this.bi = bi;
    }

    public Rectangle getBounds() {
        return new Rectangle(getMinX(),
                             getMinY(),
                             getWidth(),
                             getHeight());
    }

    /**
     * fetch the bufferedImage from this node.
     */
    public BufferedImage getBufferedImage() {
        return bi;
    }

    public Object getProperty(String name) {
        return bi.getProperty(name);
    }

    public String [] getPropertyNames() {
        return bi.getPropertyNames();
    }

    public Raster getTile(int tileX, int tileY) {
        return bi.getTile(tileX,tileY);
    }

    public Raster getData() {
        Raster r = bi.getData();
        return r.createTranslatedChild(getMinX(), getMinY());
    }

    public Raster getData(Rectangle rect) {
        Rectangle r = (Rectangle)rect.clone();

        if (r.intersects(getBounds()) == false)
            return null;
        r = r.intersection(getBounds());
        r.translate(-getMinX(), - getMinY());

        Raster ret = bi.getData(r);
        return ret.createTranslatedChild(ret.getMinX()+getMinX(), 
                                         ret.getMinY()+getMinY());
    }

    public WritableRaster copyData(WritableRaster wr) {
        WritableRaster wr2 = wr.createWritableTranslatedChild
            (wr.getMinX()-getMinX(),
             wr.getMinY()-getMinY());

        copyData(bi.getRaster(), wr2);

        /* This was the original code. This is _bad_ since it causes a
         * multiply and divide of the alpha channel to do the draw
         * operation.  I believe that at some point I switched to
         * drawImage in order to avoid some issues with
         * BufferedImage's copyData implementation but I can't
         * reproduce them now. Anyway I'm now using GraphicsUtil which
         * should generally be as fast if not faster...
         */
        /*
          BufferedImage dest;
         dest = new BufferedImage(bi.getColorModel(), 
                                  wr.createWritableTranslatedChild(0,0), 
                                  bi.getColorModel().isAlphaPremultiplied(), 
                                  null);
         java.awt.Graphics2D g2d = dest.createGraphics();
         g2d.drawImage(bi, null, getMinX()-wr.getMinX(), 
                       getMinY()-wr.getMinY());
         g2d.dispose(); 
         */
        return wr;
    }

	/**
	 * Copies data from one raster to another. Only the region of overlap between src and dst is copied.  <tt>Src</tt> and <tt>Dst</tt> must have compatible SampleModels.
	 * @param src  The source of the data
	 * @param dst  The destination for the data.
	 */
	public static void copyData(Raster src, WritableRaster dst) {
		if (is_INT_PACK_Data(src.getSampleModel(), false)
				&& is_INT_PACK_Data(dst.getSampleModel(), false)) {
			copyData_INT_PACK(src, dst);
			return;
		}
		copyData_FALLBACK(src, dst);
	}

	public static boolean is_INT_PACK_Data(SampleModel sm, boolean requireAlpha) {
		if (!(sm instanceof SinglePixelPackedSampleModel))
			return false;
		if (sm.getDataType() != DataBuffer.TYPE_INT)
			return false;
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) sm;
		int[] masks = sppsm.getBitMasks();
		if (masks.length == 3) {
			if (requireAlpha)
				return false;
		} else if (masks.length != 4)
			return false;
		if (masks[0] != 0x00ff0000)
			return false;
		if (masks[1] != 0x0000ff00)
			return false;
		if (masks[2] != 0x000000ff)
			return false;
		if ((masks.length == 4) && (masks[3] != 0xff000000))
			return false;
		return true;
	}

	/**
	 * An internal optimized version of copyData designed to work on Integer packed data with a SinglePixelPackedSampleModel.  Only the region of overlap between src and dst is copied. Calls to this should be preflighted with is_INT_PACK_Data on both src and dest (requireAlpha can be false).
	 * @param src  The source of the data
	 * @param dst  The destination for the data.
	 */
	public static void copyData_INT_PACK(Raster src, WritableRaster dst) {
		int x0 = dst.getMinX();
		if (x0 < src.getMinX())
			x0 = src.getMinX();
		int y0 = dst.getMinY();
		if (y0 < src.getMinY())
			y0 = src.getMinY();
		int x1 = dst.getMinX() + dst.getWidth() - 1;
		if (x1 > src.getMinX() + src.getWidth() - 1)
			x1 = src.getMinX() + src.getWidth() - 1;
		int y1 = dst.getMinY() + dst.getHeight() - 1;
		if (y1 > src.getMinY() + src.getHeight() - 1)
			y1 = src.getMinY() + src.getHeight() - 1;
		int width = x1 - x0 + 1;
		int height = y1 - y0 + 1;
		SinglePixelPackedSampleModel srcSPPSM;
		srcSPPSM = (SinglePixelPackedSampleModel) src.getSampleModel();
		final int srcScanStride = srcSPPSM.getScanlineStride();
		DataBufferInt srcDB = (DataBufferInt) src.getDataBuffer();
		final int[] srcPixels = srcDB.getBankData()[0];
		final int srcBase = (srcDB.getOffset() + srcSPPSM.getOffset(
				x0 - src.getSampleModelTranslateX(),
				y0 - src.getSampleModelTranslateY()));
		SinglePixelPackedSampleModel dstSPPSM;
		dstSPPSM = (SinglePixelPackedSampleModel) dst.getSampleModel();
		final int dstScanStride = dstSPPSM.getScanlineStride();
		DataBufferInt dstDB = (DataBufferInt) dst.getDataBuffer();
		final int[] dstPixels = dstDB.getBankData()[0];
		final int dstBase = (dstDB.getOffset() + dstSPPSM.getOffset(
				x0 - dst.getSampleModelTranslateX(),
				y0 - dst.getSampleModelTranslateY()));
		if ((srcScanStride == dstScanStride) && (srcScanStride == width)) {
			System.arraycopy(srcPixels, srcBase, dstPixels, dstBase, width
					* height);
		} else if (width > 128) {
			int srcSP = srcBase;
			int dstSP = dstBase;
			for (int y = 0; y < height; y++) {
				System.arraycopy(srcPixels, srcSP, dstPixels, dstSP, width);
				srcSP += srcScanStride;
				dstSP += dstScanStride;
			}
		} else {
			for (int y = 0; y < height; y++) {
				int srcSP = srcBase + y * srcScanStride;
				int dstSP = dstBase + y * dstScanStride;
				for (int x = 0; x < width; x++)
					dstPixels[dstSP++] = srcPixels[srcSP++];
			}
		}
	}

	public static void copyData_FALLBACK(Raster src, WritableRaster dst) {
		int x0 = dst.getMinX();
		if (x0 < src.getMinX())
			x0 = src.getMinX();
		int y0 = dst.getMinY();
		if (y0 < src.getMinY())
			y0 = src.getMinY();
		int x1 = dst.getMinX() + dst.getWidth() - 1;
		if (x1 > src.getMinX() + src.getWidth() - 1)
			x1 = src.getMinX() + src.getWidth() - 1;
		int y1 = dst.getMinY() + dst.getHeight() - 1;
		if (y1 > src.getMinY() + src.getHeight() - 1)
			y1 = src.getMinY() + src.getHeight() - 1;
		int width = x1 - x0 + 1;
		int height = y1 - y0 + 1;
		int[] data = null;
		for (int y = y0; y <= y1; y++) {
			data = src.getPixels(x0, y, width, 1, data);
			dst.setPixels(x0, y, width, 1, data);
		}
	}
}

//*********************REFACTORED CODE ****************
