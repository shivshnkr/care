/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package org.apache.batik.ext.awt.image.rendered;

import org.apache.batik.ext.awt.image.GraphicsUtil;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Transparency;

import java.awt.RenderingHints;

import java.awt.color.ColorSpace;

import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;

import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.Raster;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;
import java.awt.image.SampleModel;
import java.awt.image.ColorModel;
import java.awt.image.BufferedImage;
import java.awt.image.AffineTransformOp;
 
/**
 * This is an implementation of an affine operation as a RenderedImage.
 * Right now the implementation makes use of the AffineBufferedImageOp
 * to do the work.  Eventually this may move to be more tiled in nature.
 *
 * @author <a href="mailto:Thomas.DeWeeese@Kodak.com">Thomas DeWeese</a>
 * @version $Id: AffineRed.java,v 1.1 2003/04/11 07:56:53 tom Exp $ */
public class AffineRed extends AbstractRed {

    RenderingHints  hints;
    AffineTransform src2me;
    AffineTransform me2src;

    public AffineTransform getTransform() {
        return (AffineTransform)src2me.clone();
    }

    public CachableRed getSource() {
        return (CachableRed)getSources().get(0);
    }

    public AffineRed(CachableRed     src,
                     AffineTransform src2me,
                     RenderingHints  hints) {
        super(); // We _must_ call init...

        this.src2me = src2me;
        this.hints  = hints;

        try {
            me2src = src2me.createInverse();
        } catch (NoninvertibleTransformException nite) {
            me2src = null;
        }

        // Calculate my bounds by applying the affine transform to
        // my input data..codec/
        Rectangle srcBounds = src.getBounds();
        // srcBounds.grow(-1,-1);
        Rectangle myBounds;
        myBounds = src2me.createTransformedShape(srcBounds).getBounds();

        // If the output buffer is not premultiplied in certain cases it
        // fails to properly divide out the Alpha (it always does
        // the affine on premultiplied data), hence you get ugly
        // back aliasing effects...
        ColorModel cm = fixColorModel(src);

        // fix my sample model so it makes sense given my size.
        SampleModel sm = fixSampleModel(src, cm, myBounds);

        Point2D pt = new Point2D.Float(src.getTileGridXOffset(),
                                       src.getTileGridYOffset());
        pt = src2me.transform(pt, null);
        
        // Finish initializing our base class...
        init(src, myBounds, cm, sm,
             (int)pt.getX(), (int)pt.getY(), null);
    }

    public WritableRaster copyData(WritableRaster wr) {

        // System.out.println("Affine CopyData:" + wr);

        // copyToRaster(wr);
        PadRed.ZeroRecter zr = PadRed.ZeroRecter.getZeroRecter(wr);
        zr.zeroRect(new Rectangle(wr.getMinX(), wr.getMinY(), 
                                  wr.getWidth(), wr.getHeight()));
        genRect(wr);
        return wr;
    }

    public Raster getTile(int x, int y) {
        if (me2src == null)
            return null;

        int tx = tileGridXOff+x*tileWidth;
        int ty = tileGridYOff+y*tileHeight;
        Point pt = new Point(tx, ty);
        WritableRaster wr = Raster.createWritableRaster(sm, pt);
        genRect(wr);
        
        return wr;
    }

    public void genRect(WritableRaster wr) {
        if (me2src == null)
            return;

        Rectangle srcR 
            = me2src.createTransformedShape(wr.getBounds()).getBounds();

        // System.out.println("Affine wrR: " + wr.getBounds());
        // System.out.println("Affine srcR: " + srcR);

        // Outset by two pixels so we get context for interpolation...
        srcR.setBounds(srcR.x-1, srcR.y-1, srcR.width+2, srcR.height+2);

        // Don't try and get data from src that it doesn't have...
        CachableRed src = (CachableRed)getSources().get(0);

        // Raster srcRas = src.getData(srcR);

        if (srcR.intersects(src.getBounds()) == false)
            return;
        Raster srcRas = src.getData(srcR.intersection(src.getBounds()));

        if (srcRas == null)
            return;

        // This works around the problem that the buffered ops
        // completely ignore the coords of the Rasters passed in.
        AffineTransform aff = (AffineTransform)src2me.clone();

        // Translate what is at 0,0 (which will be what our current
        // minX/Y is) to our current minX,minY.
        aff.concatenate(AffineTransform.getTranslateInstance
                        (srcRas.getMinX(), srcRas.getMinY()));

        Point2D srcPt = new Point2D.Float(wr.getMinX(), wr.getMinY());
        srcPt         = me2src.transform(srcPt, null);

        Point2D destPt = new Point2D.Double(srcPt.getX()-srcRas.getMinX(), 
                                            srcPt.getY()-srcRas.getMinY());

        destPt = aff.transform(destPt, null);


        // Translate what will be at minX,minY to zero, zero
        // which where java2d will think the real minX,minY is.
        aff.preConcatenate(AffineTransform.getTranslateInstance
                           (-destPt.getX(), -destPt.getY()));

        AffineTransformOp op = new AffineTransformOp(aff, hints);

        BufferedImage srcBI, myBI;
        ColorModel srcCM = src.getColorModel();
        ColorModel myCM = getColorModel();

        WritableRaster srcWR = (WritableRaster)srcRas;
        // If the output buffer is not premultiplied in certain cases
        // it fails to properly divide out the Alpha (it always does
        // the affine on premultiplied data). We help it out by
        // premultiplying for it.
        srcCM = coerceData(srcWR, srcCM, true);
        srcBI = new BufferedImage(srcCM,
                                  srcWR.createWritableTranslatedChild(0,0),
                                  srcCM.isAlphaPremultiplied(), null);

        myBI = new BufferedImage(myCM,wr.createWritableTranslatedChild(0,0),
                                 myCM.isAlphaPremultiplied(), null);

        op.filter(srcBI, myBI);

        // if ((count % 40) == 0) {
        //     org.apache.batik.ImageDisplay.showImage("Src: " , srcBI);
        //     org.apache.batik.ImageDisplay.showImage("Dst: " , myBI);
        // }
        // count++;
    }

    // int count=0;

    protected static ColorModel fixColorModel(CachableRed src) {
        ColorModel  cm = src.getColorModel();

        if (cm.hasAlpha()) {
            if (!cm.isAlphaPremultiplied())
                cm = coerceColorModel(cm, true);
            return cm;
        }

        ColorSpace cs = cm.getColorSpace();

        int b = src.getSampleModel().getNumBands()+1;
        if (b == 4) {
            int [] masks = new int[4];
            for (int i=0; i < b-1; i++) 
                masks[i] = 0xFF0000 >> (8*i);
            masks[3] = 0xFF << (8*(b-1));

            return new DirectColorModel(cs, 8*b, masks[0], masks[1], 
                                        masks[2], masks[3],
                                        true, DataBuffer.TYPE_INT);
        }

        int [] bits = new int[b];
        for (int i=0; i<b; i++)
            bits[i] = 8;
        return new ComponentColorModel(cs, bits, true, true, 
                                       Transparency.TRANSLUCENT,
                                       DataBuffer.TYPE_INT);
        
    }

    /**
         * This function 'fixes' the source's sample model.
         * right now it just ensures that the sample model isn't
         * much larger than my width.
         */
    protected SampleModel fixSampleModel(CachableRed src,
                                         ColorModel  cm,
                                         Rectangle   bounds) {
        SampleModel sm = src.getSampleModel();
        int defSz = AbstractTiledRed.getDefaultTileSize();

        int w = sm.getWidth();
        if (w < defSz) w = defSz;
        if (w > bounds.width)  w = bounds.width;
        int h = sm.getHeight();
        if (h < defSz) h = defSz;
        if (h > bounds.height) h = bounds.height;

        if ((w <= 0) || (h <= 0)) {
            w = 1;
            h = 1;
        }

        return cm.createCompatibleSampleModel(w, h);
    }

	/**
	 * Coerces data within a bufferedImage to match newAlphaPreMult, Note that this can not change the colormodel of bi so you
	 * @param wr  The raster to change the state of.
	 * @param cm  The colormodel currently associated with data in wr.
	 * @param newAlphaPreMult  The desired state of alpha Premult for raster.
	 * @return  A new colormodel that matches newAlphaPreMult.
	 */
	public static ColorModel coerceData(WritableRaster wr, ColorModel cm,
			boolean newAlphaPreMult) {
		if (cm.hasAlpha() == false)
			return cm;
		if (cm.isAlphaPremultiplied() == newAlphaPreMult)
			return cm;
		int[] pixel = null;
		int bands = wr.getNumBands();
		float norm;
		if (newAlphaPreMult) {
			if (is_BYTE_COMP_Data(wr.getSampleModel()))
				mult_BYTE_COMP_Data(wr);
			else if (is_INT_PACK_Data(wr.getSampleModel(), true))
				mult_INT_PACK_Data(wr);
			else {
				norm = 1f / 255f;
				int x0, x1, y0, y1, a, b;
				float alpha;
				x0 = wr.getMinX();
				x1 = x0 + wr.getWidth();
				y0 = wr.getMinY();
				y1 = y0 + wr.getHeight();
				for (int y = y0; y < y1; y++)
					for (int x = x0; x < x1; x++) {
						pixel = wr.getPixel(x, y, pixel);
						a = pixel[bands - 1];
						if ((a >= 0) && (a < 255)) {
							alpha = a * norm;
							for (b = 0; b < bands - 1; b++)
								pixel[b] = (int) (pixel[b] * alpha + 0.5f);
							wr.setPixel(x, y, pixel);
						}
					}
			}
		} else {
			if (is_BYTE_COMP_Data(wr.getSampleModel()))
				divide_BYTE_COMP_Data(wr);
			else if (is_INT_PACK_Data(wr.getSampleModel(), true))
				divide_INT_PACK_Data(wr);
			else {
				int x0, x1, y0, y1, a, b;
				float ialpha;
				x0 = wr.getMinX();
				x1 = x0 + wr.getWidth();
				y0 = wr.getMinY();
				y1 = y0 + wr.getHeight();
				for (int y = y0; y < y1; y++)
					for (int x = x0; x < x1; x++) {
						pixel = wr.getPixel(x, y, pixel);
						a = pixel[bands - 1];
						if ((a > 0) && (a < 255)) {
							ialpha = 255 / (float) a;
							for (b = 0; b < bands - 1; b++)
								pixel[b] = (int) (pixel[b] * ialpha + 0.5f);
							wr.setPixel(x, y, pixel);
						}
					}
			}
		}
		return coerceColorModel(cm, newAlphaPreMult);
	}

	/**
	 * Create a new ColorModel with it's alpha premultiplied state matching newAlphaPreMult.
	 * @param cm  The ColorModel to change the alpha premult state of.
	 * @param newAlphaPreMult  The new state of alpha premult.
	 * @return    A new colorModel that has isAlphaPremultiplied() equal to newAlphaPreMult.
	 */
	public static ColorModel coerceColorModel(ColorModel cm,
			boolean newAlphaPreMult) {
		if (cm.isAlphaPremultiplied() == newAlphaPreMult)
			return cm;
		WritableRaster wr = cm.createCompatibleWritableRaster(1, 1);
		return cm.coerceData(wr, newAlphaPreMult);
	}

	public static boolean is_BYTE_COMP_Data(SampleModel sm) {
		if (!(sm instanceof ComponentSampleModel))
			return false;
		if (sm.getDataType() != DataBuffer.TYPE_BYTE)
			return false;
		return true;
	}

	protected static void mult_BYTE_COMP_Data(WritableRaster wr) {
		ComponentSampleModel csm;
		csm = (ComponentSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = csm.getScanlineStride();
		final int pixStride = csm.getPixelStride();
		final int[] bandOff = csm.getBandOffsets();
		DataBufferByte db = (DataBufferByte) wr.getDataBuffer();
		final int base = (db.getOffset() + csm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int a = 0;
		int aOff = bandOff[bandOff.length - 1];
		int bands = bandOff.length - 1;
		int b, i;
		final byte pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width * pixStride;
			while (sp < end) {
				a = pixels[sp + aOff] & 0xFF;
				if (a != 0xFF)
					for (b = 0; b < bands; b++) {
						i = sp + bandOff[b];
						pixels[i] = (byte) (((pixels[i] & 0xFF) * a) >> 8);
					}
				sp += pixStride;
			}
		}
	}

	public static boolean is_INT_PACK_Data(SampleModel sm, boolean requireAlpha) {
		if (!(sm instanceof SinglePixelPackedSampleModel))
			return false;
		if (sm.getDataType() != DataBuffer.TYPE_INT)
			return false;
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) sm;
		int[] masks = sppsm.getBitMasks();
		if (masks.length == 3) {
			if (requireAlpha)
				return false;
		} else if (masks.length != 4)
			return false;
		if (masks[0] != 0x00ff0000)
			return false;
		if (masks[1] != 0x0000ff00)
			return false;
		if (masks[2] != 0x000000ff)
			return false;
		if ((masks.length == 4) && (masks[3] != 0xff000000))
			return false;
		return true;
	}

	protected static void mult_INT_PACK_Data(WritableRaster wr) {
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = sppsm.getScanlineStride();
		DataBufferInt db = (DataBufferInt) wr.getDataBuffer();
		final int base = (db.getOffset() + sppsm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int n = 0;
		final int pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width;
			while (sp < end) {
				int pixel = pixels[sp];
				int a = pixel >>> 24;
				if ((a >= 0) && (a < 255)) {
					pixels[sp] = ((a << 24)
							| ((((pixel & 0xFF0000) * a) >> 8) & 0xFF0000)
							| ((((pixel & 0x00FF00) * a) >> 8) & 0x00FF00) | ((((pixel & 0x0000FF) * a) >> 8) & 0x0000FF));
				}
				sp++;
			}
		}
	}

	protected static void divide_BYTE_COMP_Data(WritableRaster wr) {
		ComponentSampleModel csm;
		csm = (ComponentSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = csm.getScanlineStride();
		final int pixStride = csm.getPixelStride();
		final int[] bandOff = csm.getBandOffsets();
		DataBufferByte db = (DataBufferByte) wr.getDataBuffer();
		final int base = (db.getOffset() + csm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int a = 0;
		int aOff = bandOff[bandOff.length - 1];
		int bands = bandOff.length - 1;
		int b, i;
		final byte pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width * pixStride;
			while (sp < end) {
				a = pixels[sp + aOff] & 0xFF;
				if (a == 0) {
					for (b = 0; b < bands; b++)
						pixels[sp + bandOff[b]] = (byte) 0xFF;
				} else if (a < 255) {
					int aFP = (0x00FF0000 / a);
					for (b = 0; b < bands; b++) {
						i = sp + bandOff[b];
						pixels[i] = (byte) (((pixels[i] & 0xFF) * aFP) >>> 16);
					}
				}
				sp += pixStride;
			}
		}
	}

	protected static void divide_INT_PACK_Data(WritableRaster wr) {
		SinglePixelPackedSampleModel sppsm;
		sppsm = (SinglePixelPackedSampleModel) wr.getSampleModel();
		final int width = wr.getWidth();
		final int scanStride = sppsm.getScanlineStride();
		DataBufferInt db = (DataBufferInt) wr.getDataBuffer();
		final int base = (db.getOffset() + sppsm.getOffset(
				wr.getMinX() - wr.getSampleModelTranslateX(),
				wr.getMinY() - wr.getSampleModelTranslateY()));
		int pixel, a, aFP, n = 0;
		final int pixels[] = db.getBankData()[0];
		for (int y = 0; y < wr.getHeight(); y++) {
			int sp = base + y * scanStride;
			final int end = sp + width;
			while (sp < end) {
				pixel = pixels[sp];
				a = pixel >>> 24;
				if (a <= 0) {
					pixels[sp] = 0x00FFFFFF;
				} else if (a < 255) {
					aFP = (0x00FF0000 / a);
					pixels[sp] = ((a << 24)
							| (((((pixel & 0xFF0000) >> 16) * aFP) & 0xFF0000))
							| (((((pixel & 0x00FF00) >> 8) * aFP) & 0xFF0000) >> 8) | (((((pixel & 0x0000FF)) * aFP) & 0xFF0000) >> 16));
				}
				sp++;
			}
		}
	} 
}

//*********************REFACTORED CODE ****************
