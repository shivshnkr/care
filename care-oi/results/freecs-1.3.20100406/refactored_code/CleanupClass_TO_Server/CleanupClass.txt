/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package freecs.core;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Iterator;
import freecs.*;
import freecs.auth.AuthManager;
import freecs.util.logger.LogWriter;

public class CleanupClass extends Thread {

   public CleanupClass () {
   }

   public void run () {
       this.setName("CleanupClass");
       log(this, "starting to clean up", Server.MSG_STATE, Server.LVL_MAJOR);
       srv.startShutdown ();
       MessageParser mpr = new MessageParser ();
       mpr.setMessageTemplate ("message.server.shutdown");
       Server.log (this, "sending shutdownmessages...", MSG_STATE, LVL_MAJOR);
       Server.log (this, "Logout users...", MSG_STATE, LVL_MAJOR);
       UserManager.mgr.sendMessage(mpr);
       Server.log (this, "Users logged out.", MSG_STATE, LVL_MAJOR);
       Server.log (this, "Closing all connections...", MSG_STATE, LVL_MAJOR);

       // 30000 millis before the CentralSelector will be forced to stop
       long killTime = System.currentTimeMillis() + 60000;
       while (!CentralSelector.stopped) try {
           if (killTime < System.currentTimeMillis()) {
               Server.log (this, "CentralSelector didn't shutdown within 60000 millis", MSG_STATE, LVL_VERBOSE);
               break;
           }
           System.out.print (".");
           Thread.sleep (1000);
       } catch (InterruptedException ie) {}
       synchronized (UserManager.mgr.ustr) {
           for (Iterator i = UserManager.mgr.users (); i.hasNext (); ) try {
               User u = (User) i.next ();
               i.remove();
               u.removeNow();
           } catch (Exception e) {
               debug(this, "caused Exception while removing user: ", e,
					Server.MSG_STATE, Server.LVL_MAJOR);
           }
       }
       Server.log (this, "Shutting down authentication", MSG_STATE, LVL_MAJOR);
       try {
           auth.shutdown ();
       } catch (Exception e) {
           Server.debug (this, "caused Exception while shutting down authentication: ", e, MSG_STATE, LVL_MAJOR);
       }
       Server.log (this, "Final cleanup done. Exiting JVM.", MSG_STATE, LVL_MAJOR);
   }
    
   public String toString () {
       return "[CleanupClass]";
   }

/**
 * Logging method configured by the loglevel mechanism
 * @param msg  the message to log
 * @param type  the type of message (MSG_ prefixed konstants are used here)
 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
 */
public static void log(Object o, String msg, short type, short lvl) {
	StringBuffer sb = new StringBuffer();
	try {
		if (LOG_MASK[type].intValue() < lvl && !DEBUG)
			return;
		sb.append("[");
		sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
		switch (lvl) {
		case LVL_MAJOR:
			sb.append("] MAJOR-| ");
			break;
		case LVL_HALT:
			sb.append("] HALT -| ");
			break;
		default:
			sb.append("]      -| ");
		}
		if (o != null) {
			sb.append(o.toString());
			sb.append(": ");
		}
		sb.append(msg);
		sb.append("\r\n");
		if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
				|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
				|| (type == MSG_STATE && LOGFILE[MSG_STATE].equals("console"))
				|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
						.equals("console"))
				|| (type == MSG_ERROR && LOGFILE[MSG_ERROR].equals("console"))) {
			System.out.print(sb.toString());
		} else {
			LogWriter.instance.addLogMessage(type, sb.toString());
		}
		if (lvl == LVL_HALT)
			System.exit(1);
	} catch (Exception e) {
		System.err.println("Server.log caused Exception for Message:");
		System.err.print(sb.toString());
		e.printStackTrace();
	}
}

/**
 * Debuging method configured by the loglevel mechanism
 * @param prefix  to write before other stuff
 * @param t  is the throwable to print the stacktrace from
 * @param type  the type of message, konstants with MSG_ prefix are used here
 * @param lvl  the level of atention to use here, konstants with LVL_ prefix are used here
 */
public static void debug(Object o, String prefix, Throwable t, short type,
		short lvl) {
	if (LOG_MASK[type].intValue() < lvl && !DEBUG)
		return;
	StringBuffer sb = new StringBuffer();
	sb.append(prefix);
	sb.append("\r\n");
	sb.append(t.toString());
	StackTraceElement ste[] = t.getStackTrace();
	for (int i = 0; i < ste.length; i++) {
		sb.append("\r\n    at ");
		sb.append(ste[i].getClassName());
		sb.append("(");
		sb.append(ste[i].getFileName());
		sb.append(":");
		sb.append(ste[i].getLineNumber());
		sb.append(")");
	}
	log(o, sb.toString(), type, lvl);
}

public static String formatDefaultTimeStamp(long ts) {
	cal.setTimeInMillis(ts);
	return defaultDateFormat.format(cal.getTime());
}

public static final short MSG_STATE = 2;
public static final short LVL_MAJOR = 1;
public static Server srv = null;
public static final short LVL_VERBOSE = 3;
public AuthManager auth;
public static Short LOG_MASK[] = new Short[7];
public static boolean DEBUG = false;
public static final short LVL_HALT = 0;
public static final short MSG_CONFIG = 0;
/**
 * LOGGING (will be moved to an extra object...
 */
public static String[] LOGFILE = { "console", "console", "console", "console",
		"console", "console", "console" };
public static final short MSG_AUTH = 1;
public static final short MSG_TRAFFIC = 3;
public static final short MSG_ERROR = 4;
public static Calendar cal = Calendar.getInstance();
public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
		"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
