/**
 * Copyright (C) 2003  Manfred Andres
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * The Connection-class is used to store connection-specific data
 * only once. 
 */
package freecs.content;

import freecs.Server;
import freecs.util.logger.LogWriter;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.channels.SocketChannel;
import java.nio.channels.SelectionKey;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Connection {
	// this is the remote-address of the socket-connection
	public InetAddress		peerAddress = null;
	public String 			peerIp = null;
	
	// this represents the real-client-ip if it has been identified
	public String 			clientIp=null;
	public InetAddress		clientAddress=null;
	
	// this is the proxy forward-chain (from the xForwardedFor headerfield)
	public String[]			fwChain = null;
	
	// true if the client has a direct-socket-connectino
	public boolean			isDirectlyConnected=false;
	
	public Connection (SelectionKey sk) {
		peerAddress 	= ((SocketChannel) sk.channel()).socket().getInetAddress();
		peerIp 		= peerAddress.getHostAddress();
		clientAddress 	= null;
		clientIp 			= null;
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	}
	
	public Connection (SelectionKey sk, String[] fwChain, boolean idc) {
		isDirectlyConnected 	= idc;
		peerAddress 			= ((SocketChannel) sk.channel()).socket().getInetAddress();
		if (peerAddress != null)
			peerIp			= peerAddress.getHostAddress();
		if (fwChain != null) {
			isDirectlyConnected 	= false;
			this.fwChain 			= fwChain;
			if (fwChain[0].indexOf(".") > -1) try {
				clientAddress = InetAddress.getByName(fwChain[0]);
				if (clientAddress != null)
					clientIp 		= clientAddress.getHostAddress();
			} catch (UnknownHostException uhe) {
				debug(this, "Unable to determine real IP for " + fwChain[0],
						uhe, Server.MSG_STATE, Server.LVL_MINOR);
			}
			return;
		} else if (!idc) {
			return;
		}
		clientAddress = peerAddress;
		if (peerAddress != null)
			clientIp 		= clientAddress.getHostAddress();
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "++++++++++++++++++++++++++++++++++++++++CREATE",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	}

	private volatile String toStringVal = null;	
	public String toString () {
		if (toStringVal == null) {
			StringBuffer sb = new StringBuffer ();
			if (!isDirectlyConnected)
				sb.append ("proxy=");
			sb.append (peerIp);
			if (!isDirectlyConnected && clientIp != null) {
				sb.append (" clientIp=");
				sb.append (clientIp);
			}
			toStringVal=sb.toString();
		}
		return toStringVal;
	}
    
    public boolean isBanable () {
        if (this.clientIp != null)
            return true;
        if (fwChain!=null && fwChain.length > 0 
                && fwChain[0]!=null && fwChain[0].length() > 0)
            return true;
        return false;
    }
    
    public boolean hasAnoProxy () {
        if (this.clientIp != null)
            return false;
        if (fwChain!=null && fwChain.length > 0 
                && fwChain[0]!=null && fwChain[0].length() > 0)
            return false;
        return true;
    }
    
    public boolean equals (Object o) {
        if (o == null)
            return false;
        if (!(o instanceof Connection))
            return false;
        Connection c = (Connection) o;
        if (this.clientIp == null && c.clientIp != null)
            return false;
        if (this.clientIp != null && !this.clientIp.equals(c.clientIp))
            return false;
        if (this.peerIp == null && c.peerIp != null)
            return false;
        if (this.peerIp != null && !this.peerIp.equals(c.peerIp))
            return false;
        if (this.fwChain == null && c.fwChain != null)
            return false;
        if (this.fwChain != null && !this.fwChain.equals(c.fwChain))
            return false;
        return true;
    }

    public int hashCode () {
        if (this.clientIp!=null && this.peerIp != null) {
            return (this.clientIp + "/" + this.peerIp).hashCode();
        } else if (this.peerIp!=null) {
            return this.peerIp.hashCode();
        } else {
            return this.clientIp.hashCode();
        }
    }
    
    public String getBanKey() {
        if (this.clientIp!=null)
            return this.clientIp;
        if (this.fwChain!=null && fwChain.length > 0) {
            StringBuffer sb = new StringBuffer();
            sb.append (this.peerIp);
            sb.append (":").append(fwChain[fwChain.length -1]);
            return sb.toString();
        }
        return null;
    }

    public void finalize() {
        if (TRACE_CREATE_AND_FINALIZE)
            log(this, "----------------------------------------FINALIZED",
					Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
    }

	/**
	 * Logging method configured by the loglevel mechanism
	 * @param msg  the message to log
	 * @param type  the type of message (MSG_ prefixed konstants are used here)
	 * @param lvl  the level of attention to use here (LVL_ prefixed konstants are used here)
	 */
	public static void log(Object o, String msg, short type, short lvl) {
		StringBuffer sb = new StringBuffer();
		try {
			if (LOG_MASK[type].intValue() < lvl && !DEBUG)
				return;
			sb.append("[");
			sb.append(Server.formatDefaultTimeStamp(System.currentTimeMillis()));
			switch (lvl) {
			case LVL_MAJOR:
				sb.append("] MAJOR-| ");
				break;
			case LVL_HALT:
				sb.append("] HALT -| ");
				break;
			default:
				sb.append("]      -| ");
			}
			if (o != null) {
				sb.append(o.toString());
				sb.append(": ");
			}
			sb.append(msg);
			sb.append("\r\n");
			if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals("console"))
					|| (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals("console"))
					|| (type == MSG_STATE && LOGFILE[MSG_STATE]
							.equals("console"))
					|| (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC]
							.equals("console"))
					|| (type == MSG_ERROR && LOGFILE[MSG_ERROR]
							.equals("console"))) {
				System.out.print(sb.toString());
			} else {
				LogWriter.instance.addLogMessage(type, sb.toString());
			}
			if (lvl == LVL_HALT)
				System.exit(1);
		} catch (Exception e) {
			System.err.println("Server.log caused Exception for Message:");
			System.err.print(sb.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Debuging method configured by the loglevel mechanism
	 * @param prefix  to write before other stuff
	 * @param t  is the throwable to print the stacktrace from
	 * @param type  the type of message, konstants with MSG_ prefix are used here
	 * @param lvl  the level of atention to use here, konstants with LVL_ prefix are used here
	 */
	public static void debug(Object o, String prefix, Throwable t, short type,
			short lvl) {
		if (LOG_MASK[type].intValue() < lvl && !DEBUG)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(prefix);
		sb.append("\r\n");
		sb.append(t.toString());
		StackTraceElement ste[] = t.getStackTrace();
		for (int i = 0; i < ste.length; i++) {
			sb.append("\r\n    at ");
			sb.append(ste[i].getClassName());
			sb.append("(");
			sb.append(ste[i].getFileName());
			sb.append(":");
			sb.append(ste[i].getLineNumber());
			sb.append(")");
		}
		log(o, sb.toString(), type, lvl);
	}

	public static String formatDefaultTimeStamp(long ts) {
		cal.setTimeInMillis(ts);
		return defaultDateFormat.format(cal.getTime());
	}

	public static boolean TRACE_CREATE_AND_FINALIZE = false;
	public static final short MSG_STATE = 2;
	public static final short LVL_VERY_VERBOSE = 4;
	public static final short LVL_MINOR = 2;
	public static Short LOG_MASK[] = new Short[7];
	public static boolean DEBUG = false;
	public static final short LVL_MAJOR = 1;
	public static final short LVL_HALT = 0;
	public static final short MSG_CONFIG = 0;
	/**
	 * LOGGING (will be moved to an extra object...
	 */
	public static String[] LOGFILE = { "console", "console", "console",
			"console", "console", "console", "console" };
	public static final short MSG_AUTH = 1;
	public static final short MSG_TRAFFIC = 3;
	public static final short MSG_ERROR = 4;
	public static Calendar cal = Calendar.getInstance();
	public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm:ss");
}
//*********************REFACTORED CODE ****************
